---  
layout: post  
title: "Swift 정리 - 10. 프로퍼티와 메서드"  
subtitle: ""  
categories: app
tags: app-swift
comments: true  
header-img: 
---  
  
> `Swift의 프로퍼티와 메서드에 대해 알아보자.`

---

[Swift.org:Properties](https://docs.swift.org/swift-book/LanguageGuide/Properties.html)
[Swift.org:Methods](https://docs.swift.org/swift-book/LanguageGuide/Methods.html)

* property : 클래스, 구조체, 열거형과 값들을 연관 짓는다.
* method : 특정 타입에 관련된 함수

# Properties

프로퍼티는 크게 세 가지로 나뉜다.

1. Stored Properties, 저장 프로퍼티 : 인스턴스의 일부로, 상수와 변수로 값을 저장한다. 클래스, 구조체에서만 사용할 수 있다.
2. Computed Properties, 연산 프로퍼티 : 저장하지 않고 값을 계산한다. 클래스, 구조체, 열거형에서 모두 사용할 수 있다.
3. Type Properties, 타입 프로퍼티 : 타입 자체와 연관되는 프로퍼티

추가로 프로퍼티의 값이 변하는지를 감시하는 property observer를 정의할 수도 있다. 프로퍼티 감시자는 저장 프로퍼티에 추가할 수 있고, 부모 클래스에서 상속받을 수 있다.

또한 여러 프로퍼티들의 getter와 setter 내에 있는 코드를 재사용하기 위해 property wrapper를 사용할 수도 있다.

## Stored Properties

저장 프로퍼티는 특정 클래스나 구조체의 인스턴스의 일부로서 저장된 상수나 변수를 의미한다. 저장 프로퍼티는 상수, 변수 모두 가능하다.

저장 프로퍼티를 정의할 때 기본값, 초깃값을 지정할 수 있다. 연산 프로퍼티도 마찬가지다.

```swift
struct FixedLengthRange {
    var firstValue: Int = 1
    let length: Int 
}
var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)
// the range represents integer values 0, 1, and 2
rangeOfThreeItems.firstValue = 6
// the range now represents integer values 6, 7, and 8

// 초깃값이 할당된 저장프로퍼티에 전달인자로 초깃값을 넘기지 않아도 된다.
var anotherRange = FixedLengthRange(length: 3)
```

구조체는 memberwise 이니셜라이저를 자동으로 생성하기 때문에 이를 사용해서 인스턴스를 생성하는데, 클래스는 그렇지 않기 때문에 초기화할 때 저장 프로퍼티에 값을 할당하기가 번거롭다.
클래스의 저장 프로퍼티에 초깃값을 지정하면 따로 사용자 정의 이니셜라이저를 구현할 필요가 없다.

```swift
class Cat {
    var name: String = "cat" // stored property
    var age: Int = 1 // stored property
}

// 초깃값을 모든 저장 프로퍼티에 지정해줬기 때문에 사용자 정의 이니셜라이저를 사용하지 않아도 된다.
var oneCat = Cat()
```

위에서 봤듯이 초깃값을 지정하니 이니셜라이저를 작성할 때 훨씬 간편해졌다. 하지만 초깃값이 아니라 다른 값으로 초기화하고 싶은 경우에는 이런 방법이 좋지 않을 수 있다.

인스턴스를 생성할 때 이니셜라이저를 통해 초깃값을 보내야 하는 이유는 저장 프로퍼티 타입이 옵셔널이 아니기 때문이다. 따라서 인스턴스의 저장 프로퍼티는 인스턴스가 생성될 때 값이 꼭 있는 상태여야 한다.
반면 저장 프로퍼티 타입이 옵셔널로 설정되어 있다면 값이 없어도 된다는 것을 의미하기 때문에 초깃값을 넣어주지 않아도 된다.

```swift
class Cat {
    var name: String // stored property
    var age: Int? // stored property
    
    // age는 옵셔널이기 때문에 이니셜라이저에서 초깃값을 전달하지 ㅇ낳아도 된다.
    init(name: String) {
        self.name = name
    }
}

var oneCat = Cat(name: "cat")
```

### Lazy Stored Properties

Lazy stored property는 프로퍼티가 처음 사용될 때까지 초깃값을 설정하지 않는 프로퍼티다. 선언할 때 `lazy` 키워드를 사용한다.

Lazy 프로퍼티는 프로퍼티의 초깃값이 인스턴스의 초기화가 완전히 끝날 때까지 알려지지 않은 값들과 같은 외부의 요소들에 의존하는 경우 유용하다. 또한 프로퍼티의 초깃값이 한 번 설정하기 굉장히 어렵고 많은 연산이 요구되는 경우에 필요하지 않을 때까지 초깃값을 계산하고 싶지 않은 경우에도 유용하다.
즉 lazy 프로퍼티를 사용해서 불필요한 성능저하나 공간 낭비를 줄일 수 있다.

```swift
class DataImporter {
    /*
    외부 파일의 데이터를 불러오는 클래스.
    초기화 하는데 오랜 시간이 걸린다는 것을 가정한다.
    */
    var filename = "data.txt"
    // the DataImporter class would provide data importing functionality here
}

class DataManager {
    lazy var importer = DataImporter()
    var data: [String] = []
    // the DataManager class would provide data management functionality here
}

let manager = DataManager()
manager.data.append("Some data")
manager.data.append("Some more data")
// manager의 importer 프로퍼티가 호출되지 않았기 때문에, importer에 할당할 DataImporter 인스턴스는 아직 생성되지 않았다.

// 호출되는 시점에 DataImporter 인스턴스가 생성됐다
print(manager.importer.filename)
```

> 멀티쓰레드와 lazy 프로퍼티
> 멀티 쓰레드 환경에서 lazy 프로퍼티에 동시다발적으로 접근하면 한 번만 초기화 된다는 보장이 없다. 생성되지 않은 lazy 프로퍼티에 많은 쓰레드가 비슷한 시점에 접근하면 여러 번 초기화 도리 수 있다.

### Computed Properties

클래스, 구조체, 열거형은 연산 프로퍼티를 정의할 수 있다. 연산 프로퍼티는 **실제로 값을 저장하지 않는다.** 대신, 다른 프로퍼티와 값들을 간점적으로 접근하고 값을 설정하기 위해 getter와 setter를 제공한다.

* getter : 인스턴스 내/외부의 값을 연산해 적절한 값을 돌려준다
* setter : 인스턴스 내부의 프로퍼티 값을 간접적으로 설정한다

저장 프로퍼티가 있는데 굳이 연산 프로퍼티를 사용해야 하는 이유는 무엇일까? 인스턴스 외부에서 메서드를 통해 인스턴스 내부의 은닉화된 값을 접근한다고 생각해보자.
보통 프로퍼티의 값을 가져오는데 메서드 한 개, 프로퍼티 값을 설정하는데 메서드 한 개 이렇게 두 개의 메서드를 사용한다. 이렇게 두 개의 메서드를 사용해도 되지만, 프로퍼티를 통해 값을 설정하는 게 **코드를 더 가독성 있게 만들 수 있고 간편하기도 하다**.

다만 연산 프로퍼티는 **읽기 전용일 수 있지만, 쓰기 전용으로 만들 수는 없다**. 메서드는 getter 메서드를 안 만들고 setter 메서드만 만들어서 쓰기 전용으로 만들 수 있는데 연산 프로퍼티는 이런 기능은 지원하지 않는다.

```swift
struct Point {
    var x = 0.0, y = 0.0
}
struct Size {
    var width = 0.0, height = 0.0
}
struct Rect {
    // 저장 프로퍼티
    var origin = Point()
    var size = Size()
    // 연산 프로퍼티
    var center: Point {
        get {
            let centerX = origin.x + (size.width / 2)
            let centerY = origin.y + (size.height / 2)
            return Point(x: centerX, y: centerY)
        }
        set(newCenter) {
            origin.x = newCenter.x - (size.width / 2)
            origin.y = newCenter.y - (size.height / 2)
        }
    }
}
var square = Rect(origin: Point(x: 0.0, y: 0.0),
                  size: Size(width: 10.0, height: 10.0))
let initialSquareCenter = square.center
// initialSquareCenter is at (5.0, 5.0)
square.center = Point(x: 15.0, y: 15.0)
print("square.origin is now at (\(square.origin.x), \(square.origin.y))")
// Prints "square.origin is now at (10.0, 10.0)"
```


ㄴdf
```ㅍㅡ로퍼티가 asdfasdfasdf'al;k
