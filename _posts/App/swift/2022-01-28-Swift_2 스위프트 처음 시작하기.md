---  
layout: post  
title: "Swift 정리 - 2. Swift 시작 전 알아야 할 규칙"  
subtitle: ""  
categories: app
tags: app-swift
comments: true  
header-img: 
---  
  
> `본격적으로 Swift를 공부하기 전 알아야 할 내용에 대해 보자.`  

---

Swift의 coding convention과 관련해서 아래의 자료들을 보면 좋을 것 같다.

1. Apple의 [API Design Guidlines](https://stackoverflow.com/questions/49507447/is-there-any-common-swift-coding-conventions)
2. [Swift style guide by Ray Wenderlich team](https://github.com/raywenderlich/swift-style-guide)
3. [SwiftLint](https://github.com/realm/SwiftLint) 프레임워크 사용

## 기본

* **용도의 분명함**이 가장 중요하다. 메서드나 프로퍼티와 같은 엔티티는 한 번 정의되지만 반복적으로 사용된다. 이런 것들을 사용하는 것이 분명하고 정확할 수 있게 디자인해야 한다. 디자인을 평가할 때, use case가 문맥 상 분명한지를 검증해야 한다.
* **분명함은 간결함보다 더 중요하다.** Swift가 간결하게 표현할 수 있다하더라도, 적은 단어로 가장 작은 코드를 작성하는 것이 목표는 아니다. Swift 코드에서 간결함은 strong type system의 부작용이며 근본적으로는 boilerplate(상용구 코드)를 줄이는 기능이다.
* **모든 정의마다 문서 주석을 작성해라.** 설명을 작성해서 얻을 수 있는 시야는 디자인에 깊은 영향을 줄 수 있으니 작성하는 것이 좋다.

**만약 API의 기능을 간단한 단어로 표현하는 것이 어렵다면 잘못된 API를 디자인 한 것이다.**


## 기본 명명 규칙

### 분명한 이용 용도를 알린다.

* **모든 단어를 포함해서 불확실성을 줄인다.**
 예를 들어 특정 위치의 인덱스에 있는 요소를 제거하는 아래의 메서드를 생각해보자.
 ```swift
  extension List {
    public mutating func remove(at position: Index) -> Element
  }
  employees.remove(at: x)
 ```
 그런데 여기에서 method signature에서 단어를 빼서 아래와 같이 만들면 그 의미가 불분명해진다.
 ```swift
 employees.remove(x) // unclear: are we removing x?
 ```
* **필요하지 않은 단어를 뺀다.** 이름 안에 있는 모든 단어는 사용된 곳에서 중요한 정보를 전달해야 한다. 주로 그냥 타입에 대한 정보를 반복하는 단어를 뺀다.
* **변수, 파라미터, 연관 타입을 그들의 타입 제약이 아닌 그들의 역할에 맞게 정한다.**
  아래와 같이 타입 이름을 다시 사용하는 것은 분명함과 표현성을 떨어뜨린다. 대신, 엔티티의 *역할*을 표현하는 이름을 정한다.
  ```swift
  var string = "Hello"
  protocol ViewController {
    associatedtype ViewType : View
  }
  class ProductionLine {
    func restock(from widgetFactory: WidgetFactory)
  }
  ```
  ```swift
  var greeting = "Hello"
  protocol ViewController {
    associatedtype ContentView : View
  }
  class ProductionLine {
    func restock(from supplier: WidgetFactory)
  }
  ```
  만약 연관 타입이 프로토콜에 강하게 묶여져 있다면 프로토콜 이름이 역할이 되는 것이고, 프로토콜 이름에 `Protocol`이라 붙이면 된다.
  ```swift
  protocol Sequence {
    associatedtype Iterator : IteratorProtocol
  }
  protocol IteratorProtocol { ... }
  ```
* 파라미터의 역할을 분명하게 하기 위해 **약한 타입 정보를 제공한다.**
  파라미터 타입이 특히 NSObject, Any, AnyObject, Int, String 등일 때 사용할 때의 타입 정보와 문맥은 의도를 완전히 전달하지 못할 수 있다. 예를 들어 아래의 코드에서 정의는 분명하지만, 어디에 사용해야 할지는 분명하지 않다.
  ```swift
  func add(_ observer: NSObject, for keyPath: String)

  grid.add(self, for: graphics) // vague
  ```
  분명함을 전달하기 위해 **역할을 설명하는 명사 뒤에 약한 타입 파라미터를 붙인다.**
  ```swift
  func addObserver(_ observer: NSObject, forKeyPath path: String)
  grid.addObserver(self, forKeyPath: graphics) // clear
  ```

### 유연한 사용을 위해 노력해라.

* **영어 문법에서 기인한 메서드와 함수 이름을 사용하자.**
  ```swift
  ✅
  x.insert(y, at: z)          “x, insert y at z”
  x.subViews(havingColor: y)  “x's subviews having color y”
  x.capitalizingNouns()       “x, capitalizing nouns”
  ⛔️
  x.insert(y, position: z)
  x.subViews(color: y)
  x.nounCapitalize()
  ```
  물론 유연성을 위해 하나 혹은 두 개의 인자 뒤의 인자가 호출의 의미에 중점을 두고 있지 않다면 위의 규칙을 어느 정도 어겨도 괜찮다.
  ```swift
  AudioUnit.instantiate(
  with: description, 
  options: [.inProcess], completionHandler: stopProgressBar)
  ```
* **팩토리 메서드 이름의 시작을 "make"라고 짓는다.** (e.g. x.makeIterator())
* **이니셜라이저와 팩토리 메서드 호출의 첫 번째 인자는 base name과 문장을 이루어서는 안된다.**
  예를 들어 아래 호출의 첫 번째 인자는 base 이름(호출자의 이름)과 문장으로 이루어지지 않는다.
  ```swift
  ✅
  let foreground = Color(red: 32, green: 64, blue: 128)
  let newPart = factory.makeWidget(gears: 42, spindles: 14)
  let ref = Link(target: destination)
  ```
  반면 아래 호출을 보면 API 설계자가 첫 번째 인자와 문법적으로 연결되도록 설계한 것을 확인할 수 있다.
  ```swift
  ⛔️
  let foreground = Color(havingRGBValuesRed: 32, green: 64, andBlue: 128)
  let newPart = factory.makeWidget(havingGearCount: 42, andSpindleCount: 14)
  let ref = Link(to: destination)
  ```
* **함수와 메서드를 그들의 부작용에 따라 네이밍해라.**
  * 부작용이 없는 것들은 명사로 지어져야 한다. e.g. `x.distance(to:y)`, `i.successor()`
  * 부작용이 있는 것은 명령형 동사로 지어져야 한다. e.g. `print(x)`, `x.sort()`, `x.append(y)`
  * **Mutating/nonmutating 메서드 쌍을 일관적으로 네이밍해라.** 
    * 연산이 원래 동사로 명명되어 있다면, 동사의 명령형을 mutating 메서드에 사용하고, nonmutating 메서드에 "ed"나 "ing" suffix를 붙인다.
      |Mutating|Nonmutating|
      |-|-|
      |`x.sort()`|`z = x.sorted()`|
      |`x.append(y)`|`z = x.appending(y)`|
    * 주로 "ed"를 우선적으로 붙이고, 이미 동사가 객체를 포함하고 있다면 "ing"을 쓴다.
      ```swift
      /// Strips all the newlines from `self`
      mutating func stripNewlines()

      /// Returns a copy of `self` with all the newlines stripped.
      func strippingNewlines() -> String
      ...
      s.stripNewlines()
      let oneLine = t.strippingNewlines()
      ```
    * 연산이 원래 명사로 명명되어 있다면, 명사를 nonmutating에 사용하고 "form" prefix를 mutating에 붙인다.
      |Mutating|Nonmutating|
      |-|-|
      |`y.formUnion(z)`|`x = y.union(z)`|
      |`c.formSuccessor(&i)`|`j = c.successor(i)`|
* **Boolean 메서드와 프로퍼티는 nonmutating일 때 수신자에 대해 단정하는 것으로 읽혀야 한다.** e.g. `x.isEmpty`, `line1.intersects(line2)`
* **무언가를 설명하는 프로토콜은 명사로 명명돼야 한다.** e.g. `Collection`
* **무언가가 가능함, 능력을 설명하는 프로토콜은 suffix `able`, `ible`, `ing`가 붙어야 한다.** e.g. `Equatable`, `ProgressReporting`
* **다른 타입, 프로퍼티, 변수, 상수는 명사로 명명되어야 한다.**


