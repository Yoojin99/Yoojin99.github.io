---  
layout: post  
title: "Swift 정리 - 4. 데이터 타입 고급"  
subtitle: ""  
categories: app
tags: app-swift
comments: true  
header-img: 
---  
  
> `Swift의 더 많은 데이터 타입을 알아보자.`  

---

## 데이터 타입 안심

[Swift.org:Type Safety and Type Inference](https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID322)

Swift가 뭔지 처음 공부했을 때도 Swift의 세 가지 특성 중 하나가 바로 **safe**였다. Swift는 type-safe 언어로, 타입에 굉장히 민감하고 엄격하다. 따라서 다른 타입끼리의 데이터 교환은 꼭 Type-Casting, 형변환을 거쳐야 한다. Swift에서의 값 타입의 데이터 교환은 엄밀히 말하면 타입캐스팅이 아닌 새로운 인스턴스를 생성해 할당하는 것이다.

### 데이터 타입 안심이란?

Swift는 데이터 타입을 안심하고 사용할 수 있는 Type-safe 언어다. Type-safe한 언어는 내가 작업하는 값들의 타입을 분명하게 할 수 있다는 걸 의미한다. 
또 타입을 안심하고 사용할 수 있다는 것은 발생할 수 있는 에러르 방지해서 실수를 줄일 수 있다는 걸 의미한다. 예를 들어 코드에서 `String`을 요구하는데 실수로 `Int` 값을 할당할 수 없다.

Swift가 type safe하기 때문에, 코드를 컴파일할 때 *type check*를 하고 맞지 않는 타입들을 에러로 표시한다. 이를 통해 개발 단계에서 에러들을 찾고 고칠 수 있다.

### 타입 추론

Type-checking을 통해 다른 타입의 값들을 작업할 때 에러를 방지할 수 있다. 하지만 이게 내가 생성하는 모든 상수와 변수의 타입을 명시해야 한다는 의미는 아니다. 만약 타입을 내가 명시하지 않으면 Swift는 *type inference*를 통해 적절한 타입을 지정해준다. 타입 추론은 내가 제공한 값들을 검사해서 코드를 컴파일 할 때 특정 표현의 타입을 컴파일러가 추론할 수 있게 해준다. 

![image](https://user-images.githubusercontent.com/41438361/167785900-fbb2c611-5447-439d-90ff-461551bdb7a3.png)

## Type Aliases

Swift에서는 기본적으로 제공된느 타입이든, 사용자가 새로 지정한 타입이든 이미 존재하는 타입에 다른 이름(별칭)을 부여할 수 있다. 별칭을 부여하고 나서도 기본 타입 이름과 별칭을 모두 사용할 수 있다. 

별칭은 `typealias` 키워드로 정의할 수 있다. 타입 별칭은 이미 존재하는 타입 이름을 문맥상 더 적절한 이름으로 부르고 싶을 때 유용하다. 특히 아래와 같이 외부 소스의 특정 사이즈의 데이터를 작업할 때 유용하다.

![image](https://user-images.githubusercontent.com/41438361/167969204-e4421da2-d734-4a51-b237-7b48eb47add2.png)

## Tuples

[Swift.org:Tuples](https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID329)

Tuple은 여러 값들을 하나의 합쳐진 값으로 만든다. 타입의 이름이 따로 지정되어 있지 않고, 개발자 마음대로 만드는 타입이다. 즉 **지정된 데이터의 묶음**이라고 할 수 있다. 튜플 내의 값들은 어떤 타입이든 될 수 있고, 값들이 같은 타입이 될 피룡가 없다. 

Swift의 튜플은 파이썬의 튜플과 유사하다. 타입 이름이 따로 없기 때문에 일정 타입의 나열만으로 튜플을 생성할 수 있다. 또한 튜플에 포함될 데이터의 개수도 자유롭게 정할 수 있다.

예를 들어 아래의 예제에서 `(404, "Not Found")`는 HTTP 상태 코드를 나타내는 튜플이다. 튜플의 컨텐츠를 별개의 상수나 변수로 분해해서 이후에 이를 사용할 수도 있다.

![image](https://user-images.githubusercontent.com/41438361/167969788-730e3395-6431-452d-809b-3d0c426d5646.png)

그리고 만약 튜플의 값 중 일부만 필요하다면 튜플을 분해할 때 무시할 부분에 underscore(\_)를 붙여 무시한다.
![image](https://user-images.githubusercontent.com/41438361/167969906-596e6376-9de2-4527-bdc8-07438e7419f5.png)

대신에 튜플 내의 요소들을 0부터 시작하는 인덱스 번호를 사용해서 접근할 수도 있다.

![image](https://user-images.githubusercontent.com/41438361/167969994-1ab2ad56-b600-45d4-ae3a-1c8bf7cb4ed8.png)

위처럼 튜플의 각 요소를 숫자를 통해 접근하면 간편하긴 하지만 다른 프로그래머가 코드를 보고 각 요소에 어떤 의미가 있는지 파악하기 힘들 수 있다. 따라서 튜플 내의 요소들에 이름을 붙여서 나중에 접근할 수도 있다.

![image](https://user-images.githubusercontent.com/41438361/167970097-49f7e677-17c9-43dd-a60e-ad5747181b81.png)

튜플은 특히 함수의 리턴 값으로 쓰일 때 유용하다. 웹페이지를 받는 함수는 페이지를 가져오는 데 성공했는지 실패했는지를 알리기 위해 `(Int, String)` 튜플 타입을 리턴해야 할 수 있다. 다른 타입의 다른 값을 담은 튜플을 리턴해서 함수는 오직 하나의 값만 리턴할 수 있을 때보다 더 많은 정보를 제공할 수 있다.

> 튜플은 연관된 값들의 집합에서 유용하게 사용될 수 있다. 튜플은 복잡한 데이터 구조의 생성에 적합하지 않기 때문에, 만약 더 복잡한 데이터 구조를 원한다면 클래스나 구조체로 설계하길 바란다.

## Collection Types

[Swift.org:Collection Types](https://docs.swift.org/swift-book/LanguageGuide/CollectionTypes.html#)

Swift은 값들의 컬렉션을 저장하는데 세 개의 주요 *collection type*을 제공하는데, 배열, 집합, 딕셔너리다. 배열은 값들의 순서가 있는 컬렉션이다. 집합은 유일한 값들을 저장하기 위한 순서가 없는 컬렉션이다. 딕셔너리는 키-값 연관성을 통해 값들을 저장하는 순서가 없는 컬렉션이다.

<img width="611" alt="image" src="https://user-images.githubusercontent.com/41438361/167970777-338c74c6-f20d-419a-a08c-b1858fee1427.png">

Swift의 배열, 집합, 딕셔너리는 항상 그들이 저장할 수 있는 값과 키의 타입을 분명하게 해야 한다. 이는 실수로 다른 타입을 저장할 수 없게 방지해준다. 또한 컬렉션에서 값을 받을 때 타입이 분명하기 때문에 헷갈리지 않고 사용할 수 있다.

> Swift의 배열, 집합, 딕셔너리 타입은 제네릭 컬렉션으로 구현되어 있다. 제네릭에 대해서는 이후에 볼 것이다.

### Mutability of Collections

만약 배열, 집합, 딕셔너리를 생성하고 변수에 할당한다면 컬렉션은 mutable하게 생성된 것이다. 이는 컬렉션을 생성한 후 값들을 추가하거나, 삭제하거나, 바꾸는 등으로 컬렉션을 바꿀 수 있다는 소리다. 만약 배열, 집합, 딕셔너리를 상수에 할당한다면 이는 immutable한 것이고, 크기와 컨텐츠는 바꿀 수 없다.

> 컬렉션이 바뀔 필요가 없다면 컬렉션을 불변하게 만드는 것이 좋다. 왜냐하면 변하지 않는 것을 굳이 변수로 선언할 필요도 없고 내가 생성한 컬렉션의 성능을 Swift 컴파일러가 최적화할 수 있기 때문이다.

### Arrays

배열은 같은 타입의 값들을 일렬로 나열한 후 순서대로 저장하는 형태의 컬렉션이다. 같은 값들이 여러 다른 위치에서 등장할 수도 있다.

> Swift의 `Array` 타입은 Foundation의 `NSArray` 클래스와 연결되어 있다.

#### Array Type Shorthand Syntax

Swift 배열의 타입은 `Array<Element>`로, `Element`에 값들의 타입을 써서 작성한다. 또 `[Element]`와 같이 간단하게 작성할 수도 있다. 주로 후자의 방법이 선호된다.

#### Creating an Empty Array

이니셜라이저 문법을 사용해서 특정 타입의 빈 배열을 만들 수 있다.

```swift
var someInts: [Int] = []
print("someInts is of type [Int] with \(someInts.count) items.")
// Prints "someInts is of type [Int] with 0 items."
```

만약 문맥상 이미 타입 정보가 주어졌다면 그냥 아래와 같이 빈 배열 리터럴을 사용해서 빈 배열을 생성할 수 있다.

```swift
someInts.append(3)
// someInts now contains 1 value of type Int
someInts = []
// someInts is now an empty array, but is still of type [Int]
```

#### Creating and Array with a Default Value

Swift의 `Array` 타입은 default 값들과 배열의 사이즈를 설정해서 배열을 생성할 수 있게 하는 이니셜라이저를 제공한다. 이 이니셜라이저의 `repeating` 부분에 기본 값을 전달하고, `count`에 이 값이 얼마나 반복될지를 설정할 수 있다.

```swift
var threeDoubles = Array(repeating: 0.0, count: 3)
// threeDoubles is of type [Double], and equals [0.0, 0.0, 0.0]
```

#### Creating an Array by Adding Two Arrays Together

양립 가능한 타입의 이미 존재하는 두 배열을 덧셈 연잔자로 더해 새로운 배열을 만들 수 있다. 새로운 배열의 타입은 더한 두 배열의 타입에서 추론된다.

```swift
var anotherThreeDoubles = Array(repeating: 2.5, count: 3)
// anotherThreeDoubles is of type [Double], and equals [2.5, 2.5, 2.5]

var sixDoubles = threeDoubles + anotherThreeDoubles
// sixDoubles is inferred as [Double], and equals [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]
```

#### Creating an Array with an Array Literal

배열 컬렉션에 하나 이상의 값을 간단히 쓸 수 있는 배열 리터럴로 배열을 생성할 수도 있다. 배열 리터럴은 대괄호 안에 콤마로 구분된 값들을 써서 표현한다.

<img width="296" alt="image" src="https://user-images.githubusercontent.com/41438361/167972634-910d9a3a-1c22-4a38-977b-e0ee4480e521.png">

```swift
var shoppingList: [String] = ["Eggs", "Milk"]
// shoppingList has been initialized with two initial items
```

`shoppingList` 변수는 문자열 값들의 배열로 선언되었고, `[String]`으로 작성되었다. 이 배열이 `String` 타입의 값만 허용하기 때문에, `String` 값들만 넣을 수 있고 예시에서 볼 수 있듯이 두 개의 `String` 값들로 배열이 초기화되었다.

Swift에는 타입 추론이 있기 때문에 같은 타입의 값들을 포함한 배열 리터럴로 배열을 초기화할 때 배열의 타입을 쓸 필요는 없다. 즉 `shoppingList` 배열은 아래와 같이 더 간단하게 쓸 수 있다.

```swift
var shoppingList = ["Eggs", "Milk"]
```

배열 리터럴에 있는 모든 값들이 같은 타입이기 때문에 Swift는 `shoppingList` 변수의 타입으로 `[String]`을 추론할 수 있는 것이다.

#### Accessing and Modifying and Array

1. 메서드
2. 프로퍼티
3. subscript 문법

을 통해서 배열에 접근하고 수정할 수 있다.

배열의 원소 개수를 알고 싶으면 읽기 전용인 `count` 프로퍼티를 확인한다.

```swift
print("The shopping list contains \(shoppingList.count) items.")
// Prints "The shopping list contains 2 items."
```

불리언 타입의 `isEmpty` 프로퍼티를 사용해서 `count`가 0인지 확인할 수 있다.

```swift
if shoppingList.isEmpty {
    print("The shopping list is empty.")
} else {
    print("The shopping list isn't empty.")
}
// Prints "The shopping list isn't empty."
```

`append(_:)` 메서드를 사용해서 배열의 끝에 새 요소를 추가할 수 있다.

```swift
shoppingList.append("Flour")
// shoppingList now contains 3 items, and someone is making pancakes
```

대신, 하나 이상의 양립 가능한 아이템들을 `+=` 연산자를 통해 배열에 추가할 수 있다.

```swift
shoppingList += ["Baking Powder"]
// shoppingList now contains 4 items
shoppingList += ["Chocolate Spread", "Cheese", "Butter"]
// shoppingList now contains 7 items
```

subscript 문법을 통해 값을 받을 수 있는데, 내가 받고 싶은 인덱스를 배열 뒤에 붙인 대괄호 안에 전달하면 된다.

```swift
var firstItem = shoppingList[0]
// firstItem is equal to "Eggs"
```

> 배열의 첫 번째 요소의 인덱스는 0이다. Swift의 배열은 항상 0-인덱스로 되어있다.

주어진 인덱스에 위치한 값을 바굴 때도 subscript 문법을 사용할 수 있다.

```swift
shoppingList[0] = "Six eggs"
// the first item in the list is now equal to "Six eggs" rather than "Eggs"
```

subscript 문법을 사용할 때 사용하는 인덱스는 유효한 인덱스여야 한다. subscript 문법을 사용해서 범위 내의 값들을 한 번에 바꿀 수 있다. 심지어 바꾸려는 값들의 개수가 범위에 포함된 원소의 개수와 다르더라도 가능하다. 아래의 예시는 "Chocolate Spread", "Cheese", "Butter"를 "Bananas"와 "Apples"로 바꾼 것이다.

```swift
shoppingList[4...6] = ["Bananas", "Apples"]
// shoppingList now contains 6 items
```

특정 인덱스에 요소를 삽입하려면 `insert(_:at:)` 매서드를 사용한다.

```swift
shoppingList.insert("Maple Syrup", at: 0)
// shoppingList now contains 7 items
// "Maple Syrup" is now the first item in the list
```

또 특정 인덱스의 아이템을 지우려면 `remove(at:)`을 사용하면 된다. 이 메서드는 특정 위치에 있는 아이템을 지우고 지워진 아이템을 반환한다.

```swift
let mapleSyrup = shoppingList.remove(at: 0)
// the item that was at index 0 has just been removed
// shoppingList now contains 6 items, and no Maple Syrup
// the mapleSyrup constant is now equal to the removed "Maple Syrup" string
```

> 만약 배열의 현재 경계 밖에 있는 인덱스에 접근하면 런타임 에러가 발생한다. 인덱스가 유효한지는 배열의 `count` 프로퍼티와 비교해서 확인할 수 있다. 배열의 유효한 최대 인덱스는 `count - 1`이다. `count`가 0일 때는 유효한 인덱스가 없다.

배열에서 원소가 지워졌을 때 그 지워진 부분(갭)은 없어지기 때문에 위에서 0번째 원소를 지운 후에 0번째 원소는 "Six eggs"가 된다.

```swift
firstItem = shoppingList[0]
// firstItem is now equal to "Six eggs"
```

`removeFirst()`를 써서 첫 번째 아이템을 지울 수 있고, `removeLast()` 메서드를 써서 마지막 아이템을 지울 수 있다.

#### Iterating Over an Array

배열의 전체 값들을 `for-in` 문을 통해 반복할 수 있다.

```swift
for item in shoppingList {
    print(item)
}
// Six eggs
// Milk
// Flour
// Baking Powder
// Bananas
```

만약 값 뿐만 아니라 정수 인덱스도 원한다면 `enumerated()` 메서드를 사용할 수 있다. 배열의 각 요소마다 `enumerated()` 메서드는 정수와 아이템으로 구성된 튜플을 반환한다. 튜플을 반복문 내에서 임시로 상수, 변수로 분해해서 사용할 수 있다.

```swift
for (index, value) in shoppingList.enumerated() {
    print("Item \(index + 1): \(value)")
}
// Item 1: Six eggs
// Item 2: Milk
// Item 3: Flour
// Item 4: Baking Powder
// Item 5: Bananas
```

### Sets

Set은 같은 타입의 유일한 데이터를 순서 없이 하나의 묶음으로 저장하는 형태의 컬렉션이다. 즉 집합 내의 값들을 모두 유일하기 때문에 중복된 값이 존재하지 않는다. 그래서 집합은 **순서가 중요하지 않거나 각 요소가 유일한 값이어야 하는 경우**에 사용한다. 

> Swift의 `Set` 타입은 Foundation의 `NSSet` 클래스에 연결되어 있다.

#### Hash Values for Set Types

집합에는 무조건 *hashable*한 타입의 값이 들어와야 한다. 즉 타입은 자체로 *hash value*를 연산하는 방법을 제공해야 한다. 해시 값은 `Int` 값으로 객체가 같다면 같은 해시 값을 가지게 된다. 즉 `a == b`라면 `a`의 해시 값은 `b`의 해시 값과 같다.

모든 Swift의 기본 타입(`String`, `Int`, `Double`, `Bool`)은 기본으로 hashable하고, 값 타입이나 딕셔너리의 키 타입으로 설정할 수 있다. 연관 값이 없는 열거형의 케이스 값들도 기본적으로 hashable하다. 열거형에 대해서는 이후에 더 자세히 볼 것이다.

> 값 타입이나 딕셔너리 키 타입을 커스텀 타입으로 설정할 수 있는데, 이 타입을 Swift 표준 라이브러리의 `Hashable` 프로토콜을 따르게 하면 된다. `hash(into:)`메서드를 구현하는 자세한 방법은 [Hashable](https://developer.apple.com/documentation/swift/hashable)을 참고해라. 프로토콜에 대해서도 나중에 자세히 볼 것이다.

#### Set Type Syntax

Swift의 집합의 타입은 `Set<Element>`로 쓰고, `Element`는 저장할 수 있는 요소의 타입이다. 배열과는 다르게, 집합은 축약해서 쓸 수 있는 형태가 없다.

#### Creating and Initializing and Empty Set

이니셜라이저 문법을 사용해서 빈 집합을 생성할 수 있다.

```swift
var letters = Set<Character>()
print("letters is of type Set<Character> with \(letters.count) items.")
// Prints "letters is of type Set<Character> with 0 items."
```

대신 문맥상으로 이미 타입 정보가 주어졌다면 빈 배열 리터럴로 빈 집합을 생성할 수 있다.

```swift
letters.insert("a")
// letters now contains 1 value of type Character
letters = []
// letters is now an empty set, but is still of type Set<Character>
```

#### Creating a Set with an Array Literal

배열 리터럴로 집합을 초기화 할 수 있다. 

```swift
var favoriteGenres: Set<String> = ["Rock", "Classical", "Hip hop"]
// favoriteGenres has been initialized with three initial items
```

집합 타입은 배열 리터럴 하나만 있는 걸로는 추론될 수 없다. 따라서 `Set` 타입은 명시적으로 선언되어야 한다. 하지만 Swift의 타입 추론으로 한 타입만을 포함하는 배열 리터럴로 초기화 할 때는 집합 요소의 타입을 쓰지 않아도 된다. 즉 아래와 같이 다시 쓸 수 있다.

```swift
var favoriteGenres: Set = ["Rock", "Classical", "Hip hop"]
```

#### Accessing and Modifying a Set

1. 메서드
2. 프로퍼티

를 사용해서 집합에 접근하고 수정할 수 있다.

집합에 있는 요소 개수를 확인하려면 읽기 전용 `count` 프로퍼티를 사용한다.

```swift
print("I have \(favoriteGenres.count) favorite music genres.")
// Prints "I have 3 favorite music genres."
```

불리언 타입 `isEmpty` 프로퍼티를 사용해서 `count` 프로퍼티가 0인지 확인할 수 있다.

```swift
if favoriteGenres.isEmpty {
    print("As far as music goes, I'm not picky.")
} else {
    print("I have particular music preferences.")
}
// Prints "I have particular music preferences."
```

`insert(_:)` 메서드를 호출해서 새 아이템을 추가할 수 있다.

```swift
favoriteGenres.insert("Jazz")
// favoriteGenres now contains 4 items
```

`remove(_:)` 메서드를 호출해서 집합의 요소를 지울 수 있다. 이 메서드는 요소를 지우고 지워진 요소를 반환하는데, 만약 집합이 해당 요소를 가지고 있지 않았다면 `nil`을 리턴한다. 만약 모든 요소들을 지우려면 `removeAll()`를 사용할 수 있다.

```swift
if let removedGenre = favoriteGenres.remove("Rock") {
    print("\(removedGenre)? I'm over it.")
} else {
    print("I never much cared for that.")
}
// Prints "Rock? I'm over it."
```

특정 아이템이 있는지를 확인하려면 `contains(_:)` 메서드를 사용한다.

```swift
if favoriteGenres.contains("Funk") {
    print("I get up on the good foot.")
} else {
    print("It's too funky in here.")
}
// Prints "It's too funky in here."
```

#### Iterating Over a Set

`for-in` 반복문을 사용해서 


sdfsdfs
