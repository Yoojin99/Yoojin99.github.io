---  
layout: post  
title: "[iOS Programming Big Nerd Ranch] 7. 애니메이션 다루기"  
subtitle: ""  
categories: app
tags: app-ios 
comments: true  
header-img: 
---  
  
> `애니메이션을 적용하는 방법을 보자.`  

---

'애니메이션'이라는 단어는 "삶으로 끌어들이는 행동"을 의미하는 라틴어에서 파생되었다. 애플리케이션에서는 애니메이션을 이용해 인터페이스 요소들을 화면으로 스무스하게 불러올 수 있고, 사용자의 관심을 이동하는 아이템으로
불러올 수 있으며 앱이 사용자의 행동에 어떻게 반응하는지 확실히 보여줄 수 있다. 

## Basic Animations

문서를 읽는 것은 iOS 기술을 아는 것의 좋은 출발점이 된다. 먼저 사용할 애니메이션은 basic animation이다. 기본 애니메이션은 시작 값에서 끝 깞으로 이동시킨다.

![image](https://user-images.githubusercontent.com/41438361/119287987-ae3dfb00-bc82-11eb-8285-4a43f2dd32e3.png)

먼저 alpha 값(투명도)를 애니메이션으로 조정해보겠다. 여기서 하려는 것은 이전에 만들었던 Quiz 프로젝트에서 다음 질문으로 넘어갈 때, 라벨이 천천히 드러나게 하는 것이다.
UIView에 이걸 도와주는 클래스 메서드가 있는데, 그 중 가장 간단한 UIView 애니메이션 메서드는 아래와 같다.

```swift
class func animate(withDuration duration: TimeInterval, animations: ()) -> Void)
```

이 크래스 메서드는 두 개의 변수를 받고 있다. 하나는 TimeInterval 타입(Double의 별명이기도 하다.)의 `duration`이고 클로저인 `animation`이다.

### Closure

클로저는 코드에서 전달될 수 있는 기능의 집합이다. 클로저는 함수와 메서드와 비슷하다. 사실, 함수와 메서드는 클로저의 일부이다.

클로저는 함수와 메서드에 변수로써 전달되기 쉽게 가벼운 문법을 가지고 있다. 클로저는 함수나 메서드의 리턴타입도 될 수 있다. 여기서는 클로저를 이용해서 실행되었으면 하는 애니메이션을 정의할 것이다.

클로저는 변수들을 ,로 분리한 리스트와 화살표, 리턴 타입을 적어주면 된다.

```
(arguments) -> return type
```

이 문법을 보면 함수의 문법과 비슷한 것을 알 수 있다.

```swift
func functionName(arguments) -> return type
```

이제 `animation` 변수가 요구하는 클로저 부분을 보겠다.

```swift
class func animate(withDuration duration: TimeInterval, animations: ()->Void)
```

이 클로저는 아무런 인자도 받지 않고 리턴 타입도 없다. 여기서 `()`로 표기된 것은 Void과 같은 의미다. 코드 안에서 클로저를 선언하는 것은 아래와 같이 하면 된다.

```swift
{ (arguments) -> return type in
  // code
} 
```
애니메이션을 만드려면 먼저 `ViewController.siwft`에서 애니메이션을 다루고 클로저 상수를 선언하는 메서드를 만든다. 그리고 내부에서 만든 애니메이션 클로저를 `animate(withDuration:animations:)`의 인자로 전달한다.

```swift
func animateLabelTransitions() {
    let animationClosure = { () -> Void in
        self.questionLabel.alpha = 1
    }
    
    UIView.animate(withDuration: 0.5, animations: animationClosure)
}
```

이미 `questionLabel`은 화면에 노출될 때 `alpha` 값을 1로 가지고 있다. `ViewController`의 뷰가 화면에 노출될 때마다 알파 값을 0으로 만들기 위해, `viewWillAppear(_:)`를 오버라이딩한다.

```swift
override func viewWillAppear(_ animated: Bool) {
    super.viewWillAppear(animated)

    questionLabel.alpha = 0.0
}
```

위에서 선언한 `animateLabelTransitions`에서 클로저를 상수로 선언하지 않고, 바로 `UiView.animate` 함수의 인자에 클로저를 넣어버린다.

```swift
func animateLabelTransitions() {
    UIView.animate(withDuration: 0.5) {
        self.questionLabel.alpha = 1
    }
}
```

위와 같이 변경하면 두 가지를 변경하는 것이다.

1. 클로저를 anonymously 하게 전달했다.(클로저를 변수나 상수로 할당하지 않고 바로 메서드에 전달했다.)
2. 둘째로, 타입 정보를 제거했다. (문맥에서 클로저가 이를 추론할 수 있다.)

이제 사용자가 `Next Question` 버튼을 누를때 `animateLabelTransitions()` 함수를 호출하자.

```swift
@IBAction func showNextQuestion(_ sender: UIButton) {
    currentQuestionIndex += 1

    if currentQuestionIndex == questions.count {
        currentQuestionIndex = 0
    }

    let question: String = questions[currentQuestionIndex]
    questionLabel.text = question
    answerLabel.text = "???"

    animateLabelTransitions()
}
```

현재 된 것은 처음 버튼을 터치하면 잘 동작하지만 두 번 이상 탭하면 이미 라벨이 알파 값을 1을 가지고 있기 때문에 애니메이션이 잘 작동하지 않는 것처럼 보인다. 이를 위해 라벨 하나를 더 추가하고, 버튼을 터치했을 때 현재 라벨이 fade out, 다음 라벨이 fade In 하게 설정한다. 하지만 여기까지 했을 때 계속 탭한다면, 다음 라벨이 또 일피 깂을 1을 가지고 있는 채로 남아있다. 따라서 애니메이션이 끝나면 `currentQuestionLabel`은 화면에 떠 있고, ``nextQuestionLabel`은 화면에 떠 있으면 안된다. 여기서 애니메이션의 completion handler를 사용한다.

## Animation Completion

`animate(withDuration:animations:)`는 즉시 
