---  
layout: post  
title: "[iOS Programming Big Nerd Ranch] 5. Programmatic Views, 뷰를 코드로 생성하기"  
subtitle: ""  
categories: app
tags: app-ios 
comments: true  
header-img: 
---  
  
> `view를 코드로 생성해보자.`  

---

이미 이전에 컨트롤러 두 개와 각 뷰들을 스토리보드로 만들었다. 그 중 맵 컨트롤러의 View를 선택해서 지운다.

![image](https://user-images.githubusercontent.com/41438361/118354769-b4a7e500-b5a7-11eb-8e31-a592dd00772f.png)


## Creating a View Programmatically

앞에서 뷰 컨트롤러의 뷰를 코드로 만들기 위해 `UIViewController`의 메서드 `loadView()`를 사용한다는 것을 봤다.

MapViewController.swift의 코드를 아래와 같이 작성한다.

```swift
import UIKit
import MapKit

class MapViewController: UIViewController {
    var mapView: MKMapView!
    
    override func loadView() {
        // Create a map view 
        mapView = MKMapView()
        // Set it as *the* view of this view controller
        view = mapView
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        print("MapViewController loaded its view.")
    }
}
```

뷰 컨트롤러가 생성되었을 때, `view` 프로퍼티는 nil로 설정되어 있다. 뷰 컨트롤러가 `view`를 요청했고 이 `view`가 nil이면, `loadView()` 메서드가 호출된다. 

이제 앱을 실행시키면 전과 같은 화면이 나온다.

## Programmatic Constraints

앞에서는 Interface Builder를 이용해서 Auto Layout constraints를 설정했는데, 이제는 코드로 해 볼 것이다. 

애플은 간읗나 뷰를 생성하고 제약을 설정하는 것을 Interface Builder에서 하라고 하지만, 뷰가 코드로 생성되었다면 제약 또한 코드로 해야 한다.

`~.translatesAutoresizingMaskIntoConstraints = false` 구문은 예전 시스템의 사이즈를 조정하는 인터페이스인 autoresizing masks를 설정한다. Auto Layout이 소개되기 이전에,
iOS 애플리케이션은 autoresizing mask를 이용해서 실행시간에 다른 크기의 화면들에 맞게 뷰의 크기를 조정하는 것을 가능하게 해줬다.

모든 뷰는 autoresizing mask를 가지고 있다. 기본적으로, iOS 는 autoresizing mask에 해당하는 제약을 생성해서 뷰에 추가한다. 이 전환된 constraint들은
레이아웃에 명시된 제약들과 충돌을 일으킬 수 있고, 문제가 생길 수 있다. 이 설정을 false로 설정해서 default translation을 꺼놓는 것이다.

`loadView()`안에 코드를 작성한다.

```swift
let segmentedControl = UISegmentedControl(items: ["Standard", "Hybrid", "Satellite"])
segmentedControl.backgroundColor = UIColor.white.withAlphaComponent(0.5)
segmentedControl.selectedSegmentIndex = 0
segmentedControl.translatesAutoresizingMaskIntoConstraints = false
view.addSubview(segmentedControl)
```

## Anchors

Auto Layout을 코드로 구현할 때, constraint를 만들기 위해 anchor를 사용한다. Anchor는 anchor를 다른 뷰에 맞춰 설정하고 싶은 속성들에 일치하는 뷰의 속성이다.

Anchor들은 두 anchor 사이에 제약을 생성하는 `constraint(equalTo:)`라는 메서드가 있다. `NSLayoutAnchor`에 그 외에 다른 제약을 만드는 메서드가 있다.

```swift
let topConstraint = segmentedControl.topAnchor.constraint(equalTo: view.topAnchor)
let leadingConstraint = segmentedControl.leadingAnchor.constraint(equalTo: view.leadingAnchor)
let trailingConstraint = segmentedControl.trailingAnchor.constraint(equalTo: view.trailingAnchor)
```

## Activating constraints

이제 세 개의 `NSLayoutConstraint` 인스턴스가 있지만, `isActive` 프로퍼티를 true로 만들어서 명시적으로 활성화하지 않는 이상 아무런 효과를 가지고 있지 않다.

```swift
topConstraint.isActive = true
leadingConstraint.isActive = true
trailingConstraint.isActive = true
```

제약들은 가장 제약과 연관이 있는 뷰의 가장 최근의 common ancestor에 추가되어야 한다. 아래 그림은 두 뷰의 common ancestor를 함께 보여주는 뷰 계층을 나타낸다.

![image](https://user-images.githubusercontent.com/41438361/118355922-bb395b00-b5ad-11eb-9001-d36e4e974cec.png)

만약 제약이 오직 하나의 뷰에 관련되어 있다면 뷰가 common ancestor가 된다.

`active` 프로퍼티를 true로 만들면 제약은 계층에서 제약이 추가되어야 하는 common ancestor를 찾는다. 그리고 적절한 뷰에서 `addConstraint` 메서드를 실행시킨다. 

하지만 지금까지 만든 뷰를 보면 위의 세그먼트 컨트롤이 가장 위에 있어서 가장 위의 시간을 표시하는 부분과 겹친다.

![image](https://user-images.githubusercontent.com/41438361/118355998-2125e280-b5ae-11eb-9a9d-f7eaf750870a.png)

### 새로 알게된 점

위에 작성한 코드에서, `loadView()`에서 원래는 

```swift
mapView = MKMapView()
```

로 작성해야 하는 걸 생략해버려서 mapView가 계속 nil인 상태였다. nil인 상태에서

```swift
view.addSubview(segmentedControl)
```

해버렸으니 nil에 addSubView를 한 것이었다. 위에서도 언급이 되었고 `https://stackoverflow.com/questions/4986098/viewdidload-infinite-loop-issue-ios/7370917`에서도 언급이 되었듯이, `self.view`가 존재하지 않으면 iOS는 `loadView`, `viewDidLoad` 메서드를 계속 불러서 뷰를 생성하려고 한다. 이게 무한 루프에 빠지게 해서 앱이 정상적으로 작동하지 않는 것이었다.


## Layout guides 

뷰 컨트롤러는 `topLayoutGuide`와 `bottomLayoutGuide`를 이용해서 레이아웃을 지원한다. `topLayoutGuide`를 사용하면 화면 상단에 있는 status bar나 navigation bar와 컨텐츠가 겹치지 않게 할 수 있다. 반대로 `bottomLayoutGuide`는 화면의 바닥에 있는 탭 바와 겹치지 않게 해준다.

```swift
let topConstraint = segmentedControl.topAnchor.constraint(equalTo: topLayoutGuide.bottomAnchor,
        constant: 8)
```

와 같이 topConstraint를 수정한다.

## Margins

이제 leading과 trailing 끝을 superview 안으로 좀 넣어보겠다.

모든 뷰는 컨텐츠를 표시할 때 사용하는 기본 여백을 나타내는 `layoutMargins` 프로퍼티를 가지고 있다. 이 프로퍼티는 `UIEdgeInsets`의 인스턴스이고, 프레임의 한 타입이라고 생각할 수 있다. 제약을 추가할 때, `layoutMargins`의 끝에 묶여진 anchor를 나타내는 `layoutMarginsGuide`를 사용한다.

margin을 사용하는 주 장점은 디바이스 타입과 디바이스 사이즈에 따라 margins이 바뀔 수 있다는 것이다. 코드를 아래와 같이 수정한다.

```swift
let margins = view.layoutMarginsGuide
let leadingConstraint = segmentedControl.leadingAnchor.constraint(equalTo: margins.leadingAnchor)
let trailingConstraint = segmentedControl.trailingAnchor.constraint(equalTo: margins.trailingAnchor)
```

![image](https://user-images.githubusercontent.com/41438361/118356243-2fc0c980-b5af-11eb-9a37-848c95052e7d.png)

예쁘게 바뀐 걸 확인할 수 있다.

## Explicit constraints

메서드가 제약을 어떻게 생성하는지 이해하는 것이 도움이 된다. `NSLayoutConstraint`는 아래의 이니셜라이저를 갖는다.

```swift
convenience init(item view1: Any,
                  attribute attr1: NSLayoutAttribute,
                  relatedBy relation: NSLayoutRelation, toItem view2: Any?,
                  attribute attr2: NSLayoutAttribute, multiplier: CGFloat,
                  constant c: CGFloat)
```

이 

