---  
layout: post  
title: "[iOS Programming Big Nerd Ranch] 5. Programmatic Views, 뷰를 코드로 생성하기"  
subtitle: ""  
categories: app
tags: app-ios 
comments: true  
header-img: 
---  
  
> `view를 코드로 생성해보자.`  

---

이미 이전에 컨트롤러 두 개와 각 뷰들을 스토리보드로 만들었다. 그 중 맵 컨트롤러의 View를 선택해서 지운다.

![image](https://user-images.githubusercontent.com/41438361/118354769-b4a7e500-b5a7-11eb-8e31-a592dd00772f.png)


## Creating a View Programmatically

앞에서 뷰 컨트롤러의 뷰를 코드로 만들기 위해 `UIViewController`의 메서드 `loadView()`를 사용한다는 것을 봤다.

MapViewController.swift의 코드를 아래와 같이 작성한다.

```swift
import UIKit
import MapKit

class MapViewController: UIViewController {
    var mapView: MKMapView!
    
    override func loadView() {
        // Create a map view 
        mapView = MKMapView()
        // Set it as *the* view of this view controller
        view = mapView
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        print("MapViewController loaded its view.")
    }
}
```

뷰 컨트롤러가 생성되었을 때, `view` 프로퍼티는 nil로 설정되어 있다. 뷰 컨트롤러가 `view`를 요청했고 이 `view`가 nil이면, `loadView()` 메서드가 호출된다. 

이제 앱을 실행시키면 전과 같은 화면이 나온다.

## Programmatic Constraints

앞에서는 Interface Builder를 이용해서 Auto Layout constraints를 설정했는데, 이제는 코드로 해 볼 것이다. 

애플은 간읗나 뷰를 생성하고 제약을 설정하는 것을 Interface Builder에서 하라고 하지만, 뷰가 코드로 생성되었다면 제약 또한 코드로 해야 한다.

`~.translatesAutoresizingMaskIntoConstraints = false` 구문은 예전 시스템의 사이즈를 조정하는 인터페이스인 autoresizing masks를 설정한다. Auto Layout이 소개되기 이전에,
iOS 애플리케이션은 autoresizing mask를 이용해서 실행시간에 다른 크기의 화면들에 맞게 뷰의 크기를 조정하는 것을 가능하게 해줬다.

모든 뷰는 autoresizing mask를 가지고 있다. 기본적으로, iOS 는 autoresizing mask에 해당하는 제약을 생성해서 뷰에 추가한다. 이 전환된 constraint들은
레이아웃에 명시된 제약들과 충돌을 일으킬 수 있고, 문제가 생길 수 있다. 이 설정을 false로 설정해서 default translation을 꺼놓는 것이다.

`loadView()`안에 코드를 작성한다.

```swift
let segmentedControl = UISegmentedControl(items: ["Standard", "Hybrid", "Satellite"])
segmentedControl.backgroundColor = UIColor.white.withAlphaComponent(0.5)
segmentedControl.selectedSegmentIndex = 0
segmentedControl.translatesAutoresizingMaskIntoConstraints = false
view.addSubview(segmentedControl)
```

## Anchors

Auto Layout을 코드로 구현할 때, constraint를 만들기 위해 anchor를 사용한다. Anchor는 anchor를 다른 뷰에 맞춰 설정하고 싶은 속성들에 일치하는 뷰의 속성이다.

Anchor들은 두 anchor 사이에 제약을 생성하는 `constraint(equalTo:)`라는 메서드가 있다. `NSLayoutAnchor`에 그 외에 다른 제약을 만드는 메서드가 있다.

```swift
let topConstraint = segmentedControl.topAnchor.constraint(equalTo: view.topAnchor)
let leadingConstraint = segmentedControl.leadingAnchor.constraint(equalTo: view.leadingAnchor)
let trailingConstraint = segmentedControl.trailingAnchor.constraint(equalTo: view.trailingAnchor)
```

## Activating constraints

이제 세 개의 `NSLayoutConstraint` 인스턴스가 있지만, `isActive` 프로퍼티를 true로 만들어서 명시적으로 활성화하지 않는 이상 아무런 효과를 가지고 있지 않다.

```swift
topConstraint.isActive = true
leadingConstraint.isActive = true
trailingConstraint.isActive = true
```

### 새로 알게된 점

위에 작성한 코드에서, `loadView()`에서 원래는 

```swift
mapView = MKMapView()
```

로 작성해야 하는 걸 생략해버려서 
