---  
layout: post  
title: "[iOS] - Clean Architecture, 직접 해보기"  
subtitle: ""  
categories: app
tags: app-ios 
comments: true  
header-img: 

---  
  
> `Clean architecture가 무엇인지, 또한 이를 이용해서 직접 코드를 작성해본다.`  

---

![image](https://user-images.githubusercontent.com/41438361/122940137-2a754c80-d3af-11eb-8bd4-f9394ce344a8.png)

## Clean Architecture가 뭐에요

소프트웨어를 디자인 할 때는 디자인 패턴을 사용하는 것도 중요하지만 구조적인 패턴을 사용하는 것도 중요하다. 모바일 sw 엔지니어링에서 가장 많이 사용되는 패턴들은
MVVM, Clean Architecture, Redux 패턴이 있다. 이 글에서는 **Clean Architecture**가 무엇인지 알아보고, **MVVM**과 함께 실제 코드에 적용해 보려고 한다.

개념적인 부분을 보기 위해 참고할 [Github](https://github.com/kudoleh/iOS-Clean-Architecture-MVVM) 프로젝트이다. 

![image](https://user-images.githubusercontent.com/41438361/122940567-8c35b680-d3af-11eb-9ef8-f780e999495b.png)

위의 왼쪽 그래프를 보면 여러 개의 레이어들이 존재하고 있는 것을 볼 수 있다. 이 그래프에서 핵심은 

**안쪽 레이어에 있는 애들은 바깥 레이어에 있는 것들을 몰라야 한다. 즉 안쪽 레이어에서 바깥쪽에 의존하지 말아야 한다.** DI와 DIP의 개념을 생각하면 안쪽 레이어에서 바깥쪽에
의존하지 말아야 한다는 말은 안쪽 레이어의 객체(편의상 객체라 하겠다. 클래스, 구조체 등등) 바깥쪽 레이어의 객체를 내부에서 생성하면 안된다는 것이다. Java로 예를 들자면
의존성을 갖게 되는 것은 `new`를 통해 객체를 생성하는 것과 같다.

그래서 위의 그래프에서도 dependency rule의 화살표가 안쪽으로 향하고 있다. 안쪽 레이어에 의존해야 한다는 의미다. 

### Domain, Presentation, Data Layer

![image](https://user-images.githubusercontent.com/41438361/122941787-acb24080-d3b0-11eb-84e8-d171b5e1a473.png)

이렇게 레이어를 나눴는데, 여기서 그룹을 지을 수 있다. **Domain** 레이어, **Presentation** 레이어,
그리고 **Data** 레이어가 있다.

**Domain layer(Business logic)**

그래프의 가장 안쪽에 위치한 부분이다. 가장 안쪽에 있으므로 완전히 고립되어 있는 상태로, 바깥의 애들을 아무것도 모르는 애들이다.

Entity(Business Model), Use Case, Repository Interface 를 포함한다. 이 레이어는 다른 프로젝트에서도 재사용될 수 있다.
이렇게 레이어가 분리돼서 다른 의존성이나 3rd party가 필요하지 않기 때문에 앱을 테스트할 때 환경에 구애받지 않게 하고, 따라서 도메인 Use case 테스트를
몇 초 내에 할 수 있다.

하여간 도메인 레이어의 핵심은 다른 레이어(Presentation의 UIKit/SwiftUI나 Data 레이어의 Mapping Codable)의 어떤 것도 포함시키면 안된다.

**Presentation layer**

UI(UIViewController / SwiftUI View)를 포함한다. 각 View는 하나 이상의 Use Case를 실행시키는 ViewModel(Presenters)와 대응된다. 즉
한 view에 대응되는 하나의 viewModel이 있다.

위의 과녁 모양 그래프에서도 봤듯이, 도메인 레이어에만 의존하고 있다.

**Data layer**

Repository Implementation, 그리고 하나 이상의 Data Source를 포함한다. 위에서도 언급했지만 Repository Interface는 도메인 레이어에 속했다.

Data Source는 원격이나 로컬일 수 있다. 원격일 경우는 API 호출을 통해 Json 데이터를 내려 받는 경우가 되고, 로컬일 때는 데이터베이스일 것이다.
Data Layer는 오로지 도메인 레이어에만 의존하고 있다. 여기서 헷갈리지 말아야 할게, 과녁 모양 그래프에서는 안쪽의 Presenters, 바깥에 DB, API, UI 등등이 있었는데
이 Presenters가 Presentation layer에 대응되고 가장 바깥의 영역이 Data 레이어에 대응되는 것은 아니다. 헷갈리면 위의 과녁 그래프에서 빨간색으로
그린 원들을 보자.

Data layer에는 네트워크로 받은 JSON 데이터를 도메인 모델로 매핑하는 것을 포함시킬 수 있다.

### Data Flow

![image](https://user-images.githubusercontent.com/41438361/122946258-2f88ca80-d3b4-11eb-93ba-80b9dbd46818.png)

위 그림에서는 **Dependency Direction**과 **Data flow-Request/Response**로 각 레이어를 표현하고 있다. 특히 Repository interface(protocol)
에서 **DI, 의존성 역전**이 일어나는 것을 볼 수 있다. 의존성 역전을 아주 잠깐 훑어보자면 아래의 코드로 설명할 수 있다.

```java
Coffee coffee = new Coffee; //dependency
Programmer programmer = new Programmer(coffee); // 의존성 주입. 밖에서 의존성 생성 후 주입했으므로 의존성이 역전됨
```

원래 Programmer 클래스 안에서 `new`로 생성한 Coffee 객체를 외부에서 생성해 주입한 것이다. 이처럼 원래는 Domain Use Case에서는 Data Repository에 의존하고 있으면 안되는데
Data Repository에 request와 response를 받아야 한다. 이 상황에서 Data Repository를 사용하기 위해 의존성 역전을 통해 의존성을 없애면서 Domain에서 Data Reposiotry를 사용할 수 있게 한 것이다.

**Data Flow**

1. **View(UI)**가 **ViewModel(Presenter)**의 메서드를 호출한다.
2. **ViewModel**이 **UseCase를 실행시킨다.**
3. **Use Case**가 **User**와 **Repositories**에서 데이터를 취합한다.
4. 각 **Repository**는 **Remote Data(NW), Persistent DB**저장소나 메모리 데이터를 반환한다.
5. 반환된 데이터가 우리가 아이템들을 화면에 출력할 **View**에 전달된다.

**Dependency Direction**

Presentation 레이어 ➡ Domain 레이어 ⬅️ Data Repository 레이어

* Presentation layer(MVVM) = ViewModels(Presenters) + Views(UI)
* Domain layer = Entities + Use Cases + Repositories Interfaces
* Data Repositories layer = Repositories Implementations + API(NW) + Persistence DB

## Example Project : "Movies App"

![image](https://user-images.githubusercontent.com/41438361/123020535-5cb59700-d40d-11eb-9982-f728489b706c.png)

**도메인 레이어**

위에 링크로 달아놓은 예시 프로젝트에서 도메인 레이어를 찾을 수 있다. 엔티티와 영화를 찾고 최근 쿼리를 저장하는 UseCase를 가지고 있다. 또한 DI에 필요한 Data Repositories Interface를 가지고 있다.

```swift
protocol SearchMoviesUseCase {
    func execute(requestValue: SearchMoviesUseCaseRequestValue,
                 completion: @escaping (Result<MoviesPage, Error>) -> Void) -> Cancellable?
}

final class DefaultSearchMoviesUseCase: SearchMoviesUseCase {

    private let moviesRepository: MoviesRepository
    private let moviesQueriesRepository: MoviesQueriesRepository
    
    init(moviesRepository: MoviesRepository, moviesQueriesRepository: MoviesQueriesRepository) {
        self.moviesRepository = moviesRepository
        self.moviesQueriesRepository = moviesQueriesRepository
    }
    
    func execute(requestValue: SearchMoviesUseCaseRequestValue,
                 completion: @escaping (Result<MoviesPage, Error>) -> Void) -> Cancellable? {
        return moviesRepository.fetchMoviesList(query: requestValue.query, page: requestValue.page) { result in
            
            if case .success = result {
                self.moviesQueriesRepository.saveRecentQuery(query: requestValue.query) { _ in }
            }

            completion(result)
        }
    }
}

// Repository Interfaces
protocol MoviesRepository {
    func fetchMoviesList(query: MovieQuery, page: Int, completion: @escaping (Result<MoviesPage, Error>) -> Void) -> Cancellable?
}

protocol MoviesQueriesRepository {
    func fetchRecentsQueries(maxCount: Int, completion: @escaping (Result<[MovieQuery], Error>) -> Void)
    func saveRecentQuery(query: MovieQuery, completion: @escaping (Result<MovieQuery, Error>) -> Void)
}
```

**Presentation layer**

MoviesListViewModel이 있고, 이 안의 아이템들은 MoviesListView에서 출력할 것이다. MoviesListViewModel은 UIKit을 포함하지 않는다.

```swift
// Note: We cannot have any UI frameworks(like UIKit or SwiftUI) imports here. 
protocol MoviesListViewModelInput {
    func didSearch(query: String)
    func didSelect(at indexPath: IndexPath)
}

protocol MoviesListViewModelOutput {
    var items: Observable<[MoviesListItemViewModel]> { get }
    var error: Observable<String> { get }
}

protocol MoviesListViewModel: MoviesListViewModelInput, MoviesListViewModelOutput { }

struct MoviesListViewModelActions {
    // Note: if you would need to edit movie inside Details screen and update this 
    // MoviesList screen with Updated movie then you would need this closure:
    //  showMovieDetails: (Movie, @escaping (_ updated: Movie) -> Void) -> Void
    let showMovieDetails: (Movie) -> Void
}

final class DefaultMoviesListViewModel: MoviesListViewModel {
    
    private let searchMoviesUseCase: SearchMoviesUseCase
    private let actions: MoviesListViewModelActions?
    
    private var movies: [Movie] = []
    
    // MARK: - OUTPUT
    let items: Observable<[MoviesListItemViewModel]> = Observable([])
    let error: Observable<String> = Observable("")
    
    init(searchMoviesUseCase: SearchMoviesUseCase,
         actions: MoviesListViewModelActions) {
        self.searchMoviesUseCase = searchMoviesUseCase
        self.actions = actions
    }
    
    private func load(movieQuery: MovieQuery) {
        
        searchMoviesUseCase.execute(movieQuery: movieQuery) { result in
            switch result {
            case .success(let moviesPage):
                // Note: We must map here from Domain Entities into Item View Models. Separation of Domain and View
                self.items.value += moviesPage.movies.map(MoviesListItemViewModel.init)
                self.movies += moviesPage.movies
            case .failure:
                self.error.value = NSLocalizedString("Failed loading movies", comment: "")
            }
        }
    }
}

// MARK: - INPUT. View event methods
extension MoviesListViewModel {
    
    func didSearch(query: String) {
        load(movieQuery: MovieQuery(query: query))
    }
    
    func didSelect(at indexPath: IndexPath) {
        actions?.showMovieDetails(movies[indexPath.row])
    }
}

// Note: This item view model is to display data and does not contain any domain model to prevent views accessing it
struct MoviesListItemViewModel: Equatable {
    let title: String
}

extension MoviesListItemViewModel {
    init(movie: Movie) {
        self.title = movie.title ?? ""
    }
}
```

여기에서는 MoviesListViewModelInput과 MoviesListViewModelOutput을 만들어서 MoviesListViewController를 mocking을 통해 테스트하기 쉽게 만들었다. 

UI는 비즈니스 로직이나 앱 로직에 접근할 수 없고, ViewModel만이 가능하다.

또한 View에서 ViewModel에게 영화를 찾는 것을 시작하라는 호출을 추가했다.

```swift
import UIKit

final class MoviesListViewController: UIViewController, StoryboardInstantiable, UISearchBarDelegate {
    
    private var viewModel: MoviesListViewModel!
    
    final class func create(with viewModel: MoviesListViewModel) -> MoviesListViewController {
        let vc = MoviesListViewController.instantiateViewController()
        vc.viewModel = viewModel
        return vc
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        bind(to: viewModel)
    }
    
    private func bind(to viewModel: MoviesListViewModel) {
        viewModel.items.observe(on: self) { [weak self] items in
            self?.moviesTableViewController?.items = items
        }
        viewModel.error.observe(on: self) { [weak self] error in
            self?.showError(error)
        }
    }
    
    func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {
        guard let searchText = searchBar.text, !searchText.isEmpty else { return }
        viewModel.didSearch(query: searchText)
    }
}
```

여기서는 아이템을 관찰해서 이게 바뀔 때 뷰를 다시 로드한다. 

**Data layer**

데이터 레이어는 DefaultMoviesRepository를 포함한다. 도메인 레이어에 정의된 인터페이스를 따르고, 여기에서는 JSON 데이터와 CoreData Entity들을 도메인 모델로 맵핑한다.

```swift
final class DefaultMoviesRepository {
    
    private let dataTransferService: DataTransfer
    
    init(dataTransferService: DataTransfer) {
        self.dataTransferService = dataTransferService
    }
}

extension DefaultMoviesRepository: MoviesRepository {
    
    public func fetchMoviesList(query: MovieQuery, page: Int, completion: @escaping (Result<MoviesPage, Error>) -> Void) -> Cancellable? {
        
        let endpoint = APIEndpoints.getMovies(with: MoviesRequestDTO(query: query.query,
                                                                     page: page))
        return dataTransferService.request(with: endpoint) { (response: Result<MoviesResponseDTO, Error>) in
            switch response {
            case .success(let moviesResponseDTO):
                completion(.success(moviesResponseDTO.toDomain()))
            case .failure(let error):
                completion(.failure(error))
            }
        }
    }
}

// MARK: - Data Transfer Object (DTO)
// It is used as intermediate object to encode/decode JSON response into domain, inside DataTransferService
struct MoviesRequestDTO: Encodable {
    let query: String
    let page: Int
}

struct MoviesResponseDTO: Decodable {
    private enum CodingKeys: String, CodingKey {
        case page
        case totalPages = "total_pages"
        case movies = "results"
    }
    let page: Int
    let totalPages: Int
    let movies: [MovieDTO]
}
...
// MARK: - Mappings to Domain
extension MoviesResponseDTO {
    func toDomain() -> MoviesPage {
        return .init(page: page,
                     totalPages: totalPages,
                     movies: movies.map { $0.toDomain() })
    }
}
```

## MVVM

Model-View-ViewModel 패턴은 UI와 도메인 사이를 깔끔하게 분리될 수 있게 해준다.




dd



출처

* https://tech.olx.com/clean-architecture-and-mvvm-on-ios-c9d167d9f5b3
* https://github.com/kudoleh/iOS-Clean-Architecture-MVVM
