---
title:  "Tree"
excerpt: ""

toc: true
toc_sticky: true
toc_label: "페이지 주요 목차"
header:
  teaser: 
  
  
categories:
  - 자료구조
  
tags:
  - tree
  
last_modified_at: 2020-11-03
---

트리는 스택/큐와 같은 선형 구조가 아닌 비선형 자료구조이다. 트리는 계층적 관계(Hierarchical Relationship)을 표현하는 자료구조이다.
트리라는 자료구조는 표현에 집중한다. 

## Tree

구성 요소는 아래와 같다.

* Node(노드) : 트리를 구성하고 있는 각각의 요소를 의미한다.
* Edge(간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 선을 의미한다.
* Root Node(루트 노드) : 트리 구조에서 최상위에 있는 노드를 의미한다.
* Terminal Node(=leaf Node, 단말 노드) : 하위에 다른 노드가 연결되어 있지 않는 노드를 의미한다.
* Internal Node(내부 노드, 비단말 노드) : 단말 노드를 제외한 모든 노드로 루트 노드를 포함한다.

차수랑 level이랑 헷갈릴 수 있는데, 차수는 루트 노드가 1이고, level은 루트 노드가 0이다.

## 이진 트리(Binary Tree)

루트 노드를 중심으로 두 개의 서브 트리(큰 트리에 속하는 작은 트리)로 나눠진다. 또한 나눠진 두 서브트리도 모두
이진 트리여야 한다. 공집합도 이진 트리에 포함된다. 즉 노드가 하나 뿐인 것도 이진 트리 정의에 만족한다.

트리에서는 각 층별로 숫자를 매겨서 이를 트리의 `Level`이라고 한다. 레벨의 값은 루트노드에서 0부터 시작한다. 
그리고 트리의 최고 레벨을 가리켜 해당 트리의 `height` 높이라고 한다.

### 포화 이진 트리(Perfect Binary Tree)

모든 레벨이 꽉 찬 이진 트리를 가리켜 포화 이진 트리라고 한다.

### 완전 이진 트리(Complete Binary Tree) 

위에서 아래로, 왼쪽에서 오른쪽으로 순서대로 차곡차곡 채워진 이진 트리를 가리켜 완전 이진 트리라고 한다.

### 정 이진 트리(Full BInary Tree)

모든 노드가 0개 혹은 2개의 자식 노드만을 갖는 이진 트리를 가치켜 정 이진 트리라고 한다.

배열로 구성된 Binary Tree는 노드의 개수가 n개이고 root가 0이 아닌 1에서 시작할 때, i번째 노드에 대해서

* parent(i) = i/2
* left_child(i) = 2i
* right_child(i) = 2i+1

의 인덱스를 갖는다.

## Python

우선 노드를 구현하자.

```python
class Node:
  def __init__(self, item):
    self.data = item
    self.left = None
    self.right = None
    
  def size(self):
    l = self.left.size() if self.left else 0
    r = self.left.size() if self.right else 0
    return l+r+1
    
  def depth(self):
    leftDepth = self.left.depth() if self.left else 0
    rightDepth = self.right.depth() if self.right else 0
    return leftDepth + 1 if leftDepth > rightDepth else rightDepth +1
    
  def inorder(self): // 중순위
    traverse = []
    if self.left: traverse += self.left.inorder()
    traverse.append(self.data)
    if self.right: traverse += self.right.inorder()
    return traverse
    
  def preorder(self): // 후순위
    traverse = []
    if self.left: traverse += self.left.preorder()
    if self.right: traverse += self.right.preorder()
    traverse.append(self.data)
    return traverse
    
  def postorder(self):
    traverse = []
    if self.left: traverse += self.left.preorder()
    if self.right: traverse += self.right.preorder()
    traverse.append(self.data)
    return traverse
    
class BinaryTree:
  def __init__(self, r):
    self.root = r
    
  def size(self):
    if self.root: return self.root.size()
    else : return 0
    
  def depth(self):
    if self.root: return self.root.depth()
    else: return 0
    
  def inorder(self):
    if self.root: return self.root.inorder()
    else: return []
    
  def preorder(self):
    if self.root: return self.root.preorder()
    else: return []
    
  def postorder(self):
    if self.root: return self.root.postorder()
    else: return []
```



