---  
layout: post  
title: "코드 난독화"  
subtitle: ""  
categories: soso
tags: arxan
comments: true  
header-img: 

---  
  
> `Arxan이 무엇인지, arxan이 제공하는 코드 난독화 기술은 무엇인지`  

---


어쩌다 ARXAN에 대해 들어볼 기회가 생겼다. Arxan을 쳐보니 알고보니 회사였다. 홈페이지에 들어가보니 애플리케이션 난독화를 해줘서 암호화와 위변조 방지를
해주는 것 같았다. 

![image](https://user-images.githubusercontent.com/41438361/139391288-01eb36c7-5a40-450b-97cc-6b5f946c4842.png)

그리고 이 회사가 제공하는 기술들을 보니 아래와 같은 기술들이 있었다.

![image](https://user-images.githubusercontent.com/41438361/139391346-edb3b1c4-6339-498b-bbc9-c683df851846.png)

* 코드 난독화 보호기법
* RASP 보호기법
* WBC 보호기법
* Cryptographic Key 보호기법

무슨 말인지 하나도 모르겠어서 더 찾아봤다.

## 코드 난독화 보호기법

### 난독화(Obfuscation)

난독화는 소프트웨어의 프로그램 코드를 기능은 동일하지만 분해하고 이해하기 어려운 코드로 변환하는 기술이다. 즉 코드를 읽기 어렵게 만드는 작업이라고 생각하면 된다. 난독화를 통해 소프트웨어의 도용을 방지하고 취약성을 숨길 수 있다고 한다.

![image](https://user-images.githubusercontent.com/41438361/139391625-af69a80e-e886-4b36-bb5b-6375a87ef704.png)

위 사진은 arxan 홈페이지에서 나온 사진인데, 왼쪽과 같이 구조화되어 있고 분해하기 쉬운 코드를 오른쪽과 같이 바꿔주는 걸 말하나보다. 

더 찾아보니 위키백과에서는 난독화를 하는 방법으로 아래의 방법들을 소개하고 있었다.

![image](https://user-images.githubusercontent.com/41438361/139391994-f4dc14d3-b874-4c86-8e29-6d6a3be710c2.png)

예를 들어 아래와 같은 코드가 있으면, 

```c++
int i,j;
for(i=0;i<9;i++)
for(j=0;j<9;j++)
printf("%d*%d=%d\n",i+1,j+1,(i+1)*(j+1));
```

for 를 while로 바꾸고, 특별한 변수를 사용한다.

```c++
int k=0;
int i(0),j(0);
while(k<9*9){
	i=k/9;j=k%9;
	printf("%d*%d=%d\n",i+1,j+1,(i+1)*(j+1));
	k++;
}
```

이렇게 바꿔주는 것이다. 보니까 코드를 쉽게 작성하는 것도 어렵지만 이걸 또 일부러 어렵게 바꾸는 것도 힘들구나 생각이 들었다. 

위에서 언급한 이런 절차들을 거치면 아래의 코드가

```c++
function isPrime(n:int):Boolean{
	var r:int = 0;
	while(r*r<=n)r++;
	r--;//r은 [n의 제곱근]임.
	if(n==r) return false;//n이 0 또는 1
	if(n<4) return true;
	if(n%2==0 || n%3==0 || n%r==0){
		return false;
	}
	for(var i:int = 6;i<r;i+=6){
		if(n%(i-1)==0) return n==i-1;
		if(n%(i+1)==0) return n==i+1;
	}
	return true;
}
```

아래와 같이 정말 읽기 어렵게 변경된다.

```c++
function ____(_:int,__:int=0,___:int=6):Boolean{return(__+___/___)*(__+___/___)<=_?____(_,__+___/___,___):_==__?_-_:
_<___-(__+_+__-_)/__?_/_:_%(__/__+_/_)==_-_||_%(__*___/(__+__))==__-__||_%__==___-___?___/___-_/_:___<__?
_%(___-_/_)==__/__-___/___?_==___-__/__:_%(___+___/___)==__+_-__-_?_==___+___/___:
____(_,__,___+(__*___*(_+_+_)+__*_*___+(__+__)*___*_)/_/__/___):_}
```

일단 확실한 건 웬만한 시간을 들이지 않고서야 이 함수를 이해하기는 정말 정말 힘들어 보인다.

## 역공학(reverse engineering)

코드 난독화를 얘기하려면 역공학에 대한 얘기도 하지 않을 수 없다. 아래의 글은 마이크로소프트웨어에서 2007년 12월에 기고한 글이다.

> 요즘 보안 취약점 분석자들은 각종 보안 문제 분석에 역공학(reverse engineering) 기술을 적극 활용하고 있다. 역공학은 소스 코드 없이 윈도우즈 실행 파일(PE, Portable Executable)이나, 자바 바이트코드 등을 직접 분석해서 프로그램이 어떤 기능을 수행하는지 파악하여 취약점을 찾아내는 기술이다, 필요하면 직접 프로그램 바이너리를 수정해 불법적인 일을 수행하게 만들기도 한다. 이에 대한 대응으로 코드를 복잡하게 만들어 알아보기 힘들게 하는 코드 난독화(code obfuscation) 기술이 발전하였다.

즉 역공학은 코드 없이 프로그램을 분석해서 취약점을 찾아내는 기술이다. 따라서 이런 취약점을 찾아내기 어렵게 코드 난독화 기술이 발전하게 된 것이다.

우선 역공학이 무엇인지 더 자세하게 보도록 하자.

![image](https://user-images.githubusercontent.com/41438361/139394256-eb1f961e-4195-4823-aec7-6b39d221a957.png)

대부분의 개발자들은 컴파일된 바이너리를 완전한 블랙박스로 취급한다. 기계어를 이해하기는 굉장히 어려운데, 보안 취약점 분석가들은 이런 바이너리 코드를 읽고 보안 취약점을
찾아내는 것이다. 이 작업은 전문가들에게도 어려운 작업인데, 컴파일된 바이너리를 다시 원래의 소스코드로 복구하는 프로그램인 디컴파일러의 도움을 받는다. 디컴파일러는 
원래의 소스코드를 완전히 복구하지는 못하지만, 그나마 이해하기 쉬운 소스 코드를 생성한다.

이렇게 바이너리 코드를 분석해 유용한 정보를 얻어내는 작업을 역공학(reverse engineering)이라고 한다. 실제로 역공학은 윈도우처럼 소스 코드가 공개되지 않은 운영체제나,
어플리케이션의 보안 버그를 찾아내는데 많이 사용되고 있다.

따라서 이런 역공학을 통해 취약점을 알아내기 어렵게, 즉 바이너리를 분석하기 어렵게 만들기 위해 코드 난독화가 필요하다.



* 참고
* https://skyul.tistory.com/333
