---
title:  "3. 조합_불량 사용자"
excerpt: ""

categories:
  - coding
tags:
  - 조합
last_modified_at: 
---

## 문제

[문제 링크](https://programmers.co.kr/learn/courses/30/lessons/64063)

## 아쉬웠던 부분

이번 문제는 효율성을 생각하지 않고 풀었기 때문에(어떤 방식으로 효율성을 챙겨야 하는지 감이 전혀 오지 않았다. 그나마 노드로 연결리스트를 만들어서
이미 배정된 방을 효율적으로 연결할 수 없는지 생각해봤지만 역부족이었다) 정말 처음에는 간단하게 풀었다. 그 결과 정확성 부분은 통과했지만 효율성 부분은 통과하지 못했다.


## 풀이

첫번째 풀었던 코드 : 효율성 생각안하고 정말 단순하게 푼 코드

```python
import sys
sys.setrecursionlimit(10000000)

def solution(k, room_number):
    answer = []
    
    rooms = [0 for i in range(k)]
    
    for num in room_number:
        num -= 1
        
        if rooms[num] == 0:
            rooms[num] = 1
            answer.append(num+1)
        else:
            index = num
            while rooms[index] == 1:
                index += 1
            rooms[index] = 1
            answer.append(index+1)
                
    return answer
```

참고한 효율성을 고려한 코드

```python
import sys
sys.setrecursionlimit(10000000) # 설정해주지 않으면 재귀가 많이 일어나면서 런타임에러 등이 나타날 수 있다.

def findEmptyRoom(number, rooms): # 빈방을 찾는 함수
    if number not in rooms:        
        rooms[number] = number + 1
        return number
    
    empty = findEmptyRoom(rooms[number], rooms)
    rooms[number] = empty + 1
    
    print(rooms)
    return empty


def solution(k, room_number):
    answer = []
    rooms = dict() # 몇번 방이 비어있는지 체크하는 딕셔너리

    for number in room_number:
        emptyRoom = findEmptyRoom(number, rooms)
        answer.append(emptyRoom)
        
    
    return answer
```

딕셔너리를 사용하는 연습도 해봐야겠다. 
