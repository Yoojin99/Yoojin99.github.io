---
title:  "1. 스택_크레인 인형뽑기 게임"
excerpt: ""

categories:
  - coding
tags:
  - stack
last_modified_at: 
---

코딩 실력을 기르자.


## 문제

[문제 링크](https://programmers.co.kr/learn/courses/30/lessons/64061?language=python3)

## 아쉬웠던 부분

1. board에 대한 자세한 설명이 없어서 처음에는 입출력 예시를 제대로 보지 않고 첫번째 배열이 

  [0, 0, 0, 0, 0] 이길래 나는 이게 맨 위의 가로줄인지 모르고 맨 첫번째 세로줄인줄 알고 풀어서 시간이 낭비되었다.

2. 그리고 문제를 풀다가 board가 정사각형이 아니면 어떡하지? 해서 다시 문제를 확인하니 문제 조건에 정사각형이라고 명시가 되어있었다.
  
  문제 조건을 제대로 안 읽었던 것 같다.
  
3. board에 입력값이 0이 포함되는데 이 0은 사실상 의미가 없는 값인데 나는 처음에 내가 새로 만든 스택에 이 0까지 포함해서 append 했기 때문에 조건을 확인하는 문제에서 시간이 더 많이 소요되었다.

  결국 나중에 append를 0이 아닐 때만 append 하는 것으로 바꿨다.
  
4. `[[]*number]*number` 이거 얕은 복사가 된다.
  
  `[[]*size]*size`로 배열을 만들었더니 안의 배열 각각에 원소를 추가할 때마다 다른 배열들에도 다 원소가 추가되었다.
  
  예를 들어,
  
  ```python
  board = [[]*2]*2
  
  board[0].append(1) 
  
  #내가 기대하는 결과 : [[1],[]]
  #실제로 나온 결과 : [[1], [1]]
  ```
  
  그래서 아래와 같이 코드를 바꿨다.
  
  ```python
  board = []
  
  for i in range(2):
    board.append([])
  ```
  
  이거 때문에 시간을 정말 많이 날려먹었다.

## 풀이

현재 나한테 가장 자신있는 언어는 파이썬이라 python3로 봤다.

코드

```python
def solution(board, moves):
    answer = 0
    size = len(board)
    stack = []
    answer_stack = []
    
    # 새로운 스택 만들기
    for i in range(size):
        stack.append([])
        
    index = size - 1
    
    while index >= 0 :
        for i in range(size):
            if board[index][i] != 0:
                stack[i].append(board[index][i])
        index -= 1
        
    for move in moves:
        
        if len(stack[move-1]) != 0:
            item = stack[move-1].pop()
        
            if len(answer_stack) == 0:
                answer_stack.append(item)
                
            elif len(answer_stack) > 0 :
                if answer_stack[-1] == item:
                    answer_stack.pop()
                    answer += 2
                else:
                    answer_stack.append(item)
    
    return answer
```

원래는 한 함수에 몽땅 작성했었는데, 보기도 불편해서 앞으로 가능한 부분은 함수로 따로 만들어서 풀려고 한다.

board의 세로줄마다 하나의 새로운 스택을 만든다 생각하고, 인형을 들어 갖다 놓을 answer_stack을 또 하나 만들었다.
그래서 만약 board의 크기가 5x5이면, stack은 []<= 이런 스택이 5개가 있고, answer_stack []이 하나 더 생기는 것이다.

그리고 moves에 있는 move마다 세로줄의 스택에 가서 먼저 원소가 있는지 없는지 검사했다.

1. 원소가 있다.
  1. answer_stack에 원소가 있다.
    맨 위의 원소를 꺼내서 이미 뽑은 것과 비교한다. 같으면 없어지는 인형의 수를 올리고, answer_stack에서 인형을 빼는 것을 처리한다.
    같지 않으면 answer_stack에 넣는다.
  2. answer_stack에 원소가 없다.
    그냥 answer_stack에 인형을 넣어버린다.
2. 원소가 없다.
  아무 일도 일어나지 않는다.

이 문제에서 사용된 개념은 stack이다. python으로 따로 스택을 구현할 수도 있지만 원래 있는 함수로 간단하게 스택을 흉내내게 할 수 있다.

```python
stack = [1,2,3]

#push
stack.append(원소)

#pop
number = stack.pop()

# 이때 주의할 것은 pop을 하고 나면 stack에서 원소 하나가 빠진다는 것이다.

#top
number = stack[-1]
```
