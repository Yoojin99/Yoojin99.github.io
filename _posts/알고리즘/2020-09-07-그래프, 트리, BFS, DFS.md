---
title:  "r그래프, 트리, BFS, DFS"
excerpt: ""

toc: true
toc_sticky: true
toc_label: "페이지 주요 목차"
header:
  teaser: 
  
  
categories:
  - Algorithm
  
tags:
  - 공부
  - 알고리즘
  - 그래프
  - 트리
  - BFS
  - DFS
  
last_modified_at: 
---

정말 내가 많이 헷갈리고, 코드로 이용 못하는 그래프다.

먼저, 나는 공부를 정말 대충했기 때문에 트리가 그래프에 속하는 자료구조라는 것 외에는 아무것도 몰랐다.
정말 지금 다시 보면 멍청하기 그지없다.
그래서 먼저 트리와 그래프의 정확한 정의와 그 차이에 대해서 보려고 한다.

## 그래프

일부 객체의 쌍들이 서로 연관된 객체의 집합을 이루는 구조이다. 즉 객체(노드)들과 객체들과의 관계(간선)이 있는 구조이다.
일련의 **꼭짓점**들과 꼭짓점을 잇는 **변**들로 구성된 조합론적 구조로 볼 수 있다.

1. 두개의 정점 사이에 2개 이상의 경로가 가능하다. 노드들 사이에 양방향 경로를 가질 수 있다.
2. 사이클이 존재(loop가 존재)한다.
3. 루트 노드, 부모-자식 노드라는 개념이 없다.
4. 순회는 DFS, BFS로 이루어진다.
5. 그래프는 cyclic / acyclic 이다.
6. 방향 그래프 / 무방향 그래프가 있다.
7. 네트워크 모델

## 트리
 
트리는 **그래프의 일종**으로, 여러 **노드**가 한 노드를 가리킬 수 없는 구조이다. 회로가 없고, 서로 다른
두 노드를 잇는 길이 하나뿐인 그래프를 트리라고 한다. 

1. 트리는 그래프의 특별한 케이스로, 최소연결트리 라고 불린다. 두개의 정범 사이에 반드시 1개의 경로만 가진다.
2. 사이클이 존재하지 않다.(loop 없음)
3. 부모-자식 관계가 존재 => top-bottom / bottom-top 으로 이루어진다.
4. 순회는 전순위, 중순위, 후순위로 이루어진다. 이 세가지는 모두 DFS/BFS 안에 있다.
5. 트리는 DAG(Directed Acyclic Graphs), 사이클이 없는 방향 그래프이다.
6. 간선은 항상 노드의 개수-1 만큼 가진다.
7. 계층 모델

쓰이는 기본 용어는 다음과 같다.

* 차수(edge) : 노드가 가지고 있는 자식 노드의 개수, 즉 연결하는 선의 개수가 된다. 각 노드마다 다르다. 트리의 차수는 트리가 가지고 있는 노드의 차수중 가장 큰 차수이다.
* 레벨(level) : 각 층에 번호를 매기는 것. 루트의 레벨은 1, 자식으로 갈수록 레벨이 증가한다.
* 높이(height) : 트리가 가지고 있는 최대 레벨

트리는 크게 "Binary Tree", "Non-Binary Tree"로 나뉜다.

이진트리는 각 노드에 대해 두개 **이하**의 자식을 가지고, non binary tree는 노드 자식 개수에 제한이 없다는 뜻이다.

### "non-binary tree"

가장 대표적인 사용예는 "trie" 자료구조라고 할 수 있다. 이 자료구조는 문자열 검색에 많이 사용된다.
trie에서 단점을 공간 복잡도라고 하는데, 그 이유는 모든 노드마다 자식들 노드를 가리키는 포인터를 들고 있어야 하기 때문이다.

이는 노드 별 자식을 linked list 형태로 표현하면 해결이 가능하다고 한다.

문자열을 찾는거나, 컴퓨터의 파일 시스템과 같은 경우에도 사용될 수 있다.

### "binary tree"

이진 트리는 각 노드의 자식을 2개 이하로 가지고 있다.  모든 노드가 2개의 서브 트리를 가지고 있으므로 순환적으로 정의된다.

이진트리는 노드를 하나도 갖고 있지 않을 수 있지만, 일반 트리는 노드를 1개 이상을 가지고 있어야 한다.

이진트리는 형태에 따라 포화이진트리, 완전이진트리로 나눌 수 있다.

* 포화 이진 트리 : 각 레벨에 노드가 꽉 차 있는 이진 트리. 
* 완전 이진 트리 : 높이가 k일 때, 레벨 1부터 k-1까지는 노드가 채워져 있고, 마지막 레벨에는 노드가 꽉 차 있지 않아도 되는 트리

#### BST, Binary-Search-tree

이진탐색트리이다. 유명하고, 접근성이 용이하다. 각 노드는 왼쪽 자식 트리와 오른쪽 자식 트리를 가지는 루트를 자식으로 가지고,
왼쪽 서브 트리는 루트보다 작은값을, 오른쪽 서브 트리는 루트보다 큰 값을 가지는 형태의 이진트리를 말한다.

BST는 자료의 입력, 삭제, 탐색 모두 시간 복잡도가 O(logN) 이다. 배열 이진 탐색의 경우 시간 복잡도는 동일하지만 
자료의 변경, 삭제가 불가능했다. 또한 BST를 linked list로 구현할 경우 탐색에서 O(N)의 시간이 소요된다.

시간의 복잡도가 왜 O(logN)이 되나면, 이진 탐색 트리에서 최대 탐색 횟수는 트리의 depth이다.

n개의 노드가 주어질 때, 매 depth에서 2의 노드씩으로 분할이 되기 때문에, 2^depth = N이 되고,

time = depth = logN이 된다.

#### Segment tree

tree를 이용해서 구획을 나누는 방법이다.


## 목록

- BFS
- DFS
- 이진 탐색
- 병합 정렬
- 퀵 정렬
