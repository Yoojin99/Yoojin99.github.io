---
title:  "캐시 메모리(Cache Memory)"
excerpt: ""

toc: true
toc_sticky: true
toc_label: "페이지 주요 목차"
header:
  teaser: 
  
  
categories:
  - Architecture
  
tags:
  - 
last_modified_at: 2020-10-25
---

캐시 메모리는 속도가 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리를 말한다.

예시 )

1. CPU 코어와 메모리 사이의 병목 현상 완화
2. 웹 브라우저 캐시 파일은 하드디스크와 웹페이지 사이의 병목 현상을 완화한다.

CPU가 주기억장치에 저장된 데이터를 읽어올 때, 자주 사용하는 데이터(자주 읽어오는 데이터)를 캐시 메모리에 저장한 뒤, 다음에 이용할 때에는
주기억장치가 아닌 캐시 메모리를 먼저 탐색하고 가져오면서 처리 속도를 향상시킨다.

속도가 빨라진다는 장점이 있지만, 캐시 메모리에 올릴 수 있는 메모리의 한계(용량이 작음)와 비싸다는 단점도 있다.

CPU에는 캐시 메모리가 2~3개 정도 사용된다. (L1, L2, L3 캐시 메모리라고 한다)

속도와 크기에 따라 분류한 것으로, L1 캐시부터 사용된다. (여기서 데이터를 찾지 못하면 L2로 간다.)

듀얼 코어 프로세서의 캐시 메모리 : 각 코어마다 독립된 L1 캐시 메모리를 가지고, 두 코어가 공유하는 L2 캐시 메모리가 내장된다.

만약 L1 캐시가 128kb이면 64/64로 나눈다.(I-Cache:instruction cache, D-Cache:data cache).

* L1 : CPU 내부에 존재
* L2 : CPU-RAM 사이에 존재
* L3 : 메인보드에 존재

디스크 캐시 : 주기억 장치(RAM)과 보조기억장치(하드디스크) 사이에 존재하는 캐시

## 캐시 메모리 작동 원리

* 시간 지역성
  for나 while 같은 반복문에 사용하는 조건 변수처럼 한 번 참조된 데이터는 또 참조될 확률이 높음

* 공간 지역성
  A[0], A[1]과 같이 연속된 주소, 공간을 접근할 때 참조된 데이터 근처에 있는 데이터가 잠시 후 또 사용될 가능성이 높음.
  
  캐시에 데이터를 저장할 때는 참조 지역성(공간)을 최대한 활용하기 위해 해당 데이터뿐만 아니라, 옆 주소의 데이터도 같이 가져와 미래에 쓰일 것을 대비한다.
  
CPU가 요청한 데이터가 캐시에 있으면 'Cache Hit', 없으면 'Cache Miss'이다.

## Cache Miss 3가지

1. Cold miss, compulsory miss
  해당 메모리 주소를 처음 불러서 나는 미스
  
2. Conflict miss
  캐시 메모리에 A와 B 데이터를 저장해야 하는데, A와 B가 같은 캐시 메모리 주소에 할당되어 있어서 나는 미스
  
3. Capacity miss
  캐시 메모리의 공간이 부족해서 나는 미스(Conflict는 주소 할당 문제, Capacity는 공간 문제)
  
  캐시 크기를 키울 수도 있지만, 캐시 접근 속도가 느려지고 전력을 많이 소모한다.
  
## 구조 및 작동 방식

### Direct Mapped Cache

가장 기본적인 구조로, DRAM의 여러 주소가 캐시 메모리의 한 주소에 대응되는 다대일 방식이다.

![image](https://user-images.githubusercontent.com/41438361/97106592-108f4700-1706-11eb-8eb8-7a0696e5419c.png)

그림을 보면 메모리 공간이 32개가 있고(00000 ~ 11111), 캐시 메모리 공간은 8개(000 ~ 111)인 상황이다.

이때 00000, 01000, 10000, 11000인 메모리 주소는 캐시의 000 주소에 mapping한다.

000을 "인덱스 필드", 인덱스 필드를 제외한 앞의 부분을(00, 01, 10, 11) "태그 필드" 라고 한다. 기본적으로 
태그 비트와 인덱스 비트 뒤에 저장하는 데이터 필드가 붙어있는 구조를 가지고 있다.

간단하고 빠르지만, conflict miss가 발생한다. 메모리에서 색이 같은 부분(인덱스 필드가 같은 애들)을 여러개 저장해야 하는 일이 생기면 골치하프다.

### Fully Associative Cache

비어 있는 캐시 메모리가 있으면, 마음대로 주소를 저장하는 방식이다. 

저장할 때는 간단하지만, 찾을 때가 문제이다.

조건이나 규칙이 없어서 특정 캐시 set 안에 있는 모든 블럭을 모두 탐색해서 원하는 데이터가 있는지 검색해야 한다.
이를 위해 CAM(content Addressable memory)라는 특수한 형태의 메모리 구조를 사용하는데, 가격이 아주 비싸다.

### Set Associative Cache

Direct Mapping과 Fully Associative 방법을 섞었다. 특정 row를 지정해서 그 row안의 어떤 열이든 비어 있으면 저장한다.

DMC에 비해 검색은 오래 걸리지만 저장이 빠르고, Associative에 비해 저장이 느리지만 검색이 빠르다.





