---
title:  "SOLID 원칙"

toc: true
toc_sticky: true
toc_label: "페이지 주요 목차"
header:
  teaser: 
  
  
categories:
  - 개념
  
tags:
  - 공부
  - SOLID
  - OOP
  
last_modified_at: 2020-12-02
---

OOP는 객체 지향 프로그래밍으로, 객체 지향 설계를 하는데는 5가지 원칙이 있다.

SRP(단일 책임 원칙), OCP(개방-폐쇄 원칙), LSP(리스코프 치환 원칙), ISP(인터페이스 분리 원칙), DIP(의존 역전 원칙)을 의미한다.

이 법칙들의 앞 글자를 따서 SOLID 원칙이라고 부른다.

## 1. SRP 단일 책임 원칙 (Single Responsibility Principle)

모든 클래스는 하나의 책임만을 갖고 있어야 한다. 클래스는 그 책임을 완전히 캡슐화해야 한다.

정확한 설명은 아래와 같다.

```
* 한 클래스는 단 한 가지의 변경 이유만을 가져야 한다.
* 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.
```

예를 들어 사칙 연산 함수를 가지고 있는 계산 클래스가 있다고 하자. 이 계산 클래스는 오직 사칙연산 기능만을 책임진다.
이 클래스를 수정한다면 이유는 오직 사칙연산 함수와 관련된 문제일 것이다.

단일 책임 원칙은 **응집도**와 관련이 있다.

위의 예제에서도 나왔지만, 이 **책임**이라는 것은 '변경을 위한 이유'라고 정의할 수 있다. 한 클래스를 변경하기 위한 한 가지 이상의 이유를 생각할 수 있다면,
이 클래스는 한 가지 이상의 책임을 맡고 있는 것이다.

아래와 같은 경우는 SRP를 위반했다.

```
┌─────────────┐    ┌───────────────┐    ┌───────────┐
│Computational│    │   Rectangle   │    │ Graphical │
│  Geometry   ├───>├───────────────┤<───┤Application│
│ Application │    │+ draw()       │    └─────┬─────┘
└─────────────┘    │+ area():double│          │
                   └───────┬───────┘          │
                           ↓                  │
                        ┌─────┐               │
                        │ GUI │<──────────────┘
                        └─────┘
```

Rectangle 클래스를 수정할 수 있는 이유가 두 가지(책임이 두 가지)가 있기 때문이다.
  
  * 1 : area() : 직사각형 모향의 수학적 모델 제공
  * 2 : draw() : 직사각형 그리기
  
따라서 아래와 같이 2개의 다른 클래스로 분리해서 설계할 수 있다.

```
 ┌─────────────┐     ┌───────────┐
 │Computational│     │ Graphical │──────┐
 │  Geometry   │     │Application│      │
 │ Application │     └─────┬─────┘      │
 └──────┬──────┘           │            │
        ↓                  ↓            │
┌───────────────┐    ┌───────────┐      ↓
│   Geometric   │    │ Rectangle │   ┌─────┐
│   Rectangle   │<───┼───────────┤──>│ GUI │
├───────────────┤    │+ draw()   │   └─────┘
│+ area():double│    └───────────┘
└───────────────┘
```

## OCP 개방-폐쇄 원칙(Open Closed Principle)

확장에는 열려있고, 수정에는 닫혀있어야 한다. 기존의 코드를 변경하지 않으면서(Closed), 기능을 추가할 수 있도록(Open) tjfrPrk ehldjdi gksek.

OCP의 목적은 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 것이다. 이 목표를 달성하기 위해선
시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 수정이 발생하더라도 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어져야 한다.

* OCP와 거리가 먼 소프트웨어의 경우, 변경이 단계적으로 퍼져나갈 수 있다.
* OCP를 잘 따르는 소프트웨어의 경우, 변경이 필요할 때 기존 코드를 수정하기보다는 새로운 코드를 추가하는 방법을 쓴다.

예를 들어, 캐릭터를 하나 생성한다고 할 때, 각각의 캐릭터가 움직임이 다를 경우 움직임의 패턴 구현을 하위 클래스에 맡긴다면 캐릭터 클래스의 수정은 필요가 없고(Closed), 움직임의 패턴만 재정의 하면 된다.(Open)

OCP는 지키기 어려워서, 엉클 밥은 일단 변경을 기다렸다가 해결하는 전략을 제안한다.

## LSP 리스코프 치환 원칙(Liskov Substitution Principle)

자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있다는 원칙이다. 즉 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 잘 작동해야 한다.

자식 클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행하게 되면 LSP를 만족한다.

## ISP 인터페이스 분리 원칙(Interface Segregatopm Principle)

한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다. 하나의 일반적인 인터페이스보다 여러개의 구체적인 인터페이스가 좋다.

예를 들어 A 클라이언트에서는 사용하지 않고, B 클라이언트에서는 사용하는 메서드가 있다고 하자.

이 메서드의 변경이 메서드를 사용하지 않는 클라이언트에 영향을 줄 때 인터페이스를 분리하도록 한다.

즉 클래스는 자신이 실제로 사용하는 메서드에만 의존해야 한다.

## DIP 의존 역전 원칙(Dependency Inversion Principle)

의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 말이다.
즉 구체적인 클래스보다는 인터페이스나 추상 클래스와 관계를 맺으라는 뜻이다.



출처 : https://johngrib.github.io/wiki/SOLID/, https://medium.com/@hckcksrl/solid-%EC%9B%90%EC%B9%99-182f04d0d2b
