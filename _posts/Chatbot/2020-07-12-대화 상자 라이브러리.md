---
title:  "Chatbot - 대화 상자 라이브러리"
excerpt: "Chatbot - 대화 상자 라이브러리"

toc: true
toc_sticky: true
toc_label: "페이지 주요 목차"
header:
  teaser: 
  
  
categories:
  - Chatbot
  
tags:
  - Chatbot
  - 공부
  - Azure
last_modified_at: 
---

대화 상자 라이브러리
====================

대화는 SDK 의 핵심 개념이다. 대화는 사용자와 대화를 관리하는 방법을 제공하나.

대화는 봇의 프로그램에서 함수처럼 작동하는 봇의 구조이다.

각 대화는 특정 작업을 수행하도록 되어있다. 

대화는 순서를 지정해서 대화를 안내하거나(다중 연결 대화와 같은 것을 말하는 것 같다), 사용자에게 응답하거나 등등 다양한 방식으로 호출된다.

대화 라이브러리는 대화를 더 쉽게 관리하기 위해 몇 기본 제공 대화 유형을 제공한다.

* 폭포/프롬프트 대화는 여러 대화 단계를 결합하여 특정 시퀀스를 따르게 항 정보를 한 단계에서 그 다음 단계로 전달될 수 있게 한다.
* 구성 요소 대화를 사용하면 선물세트처럼 대화 세트를 캡슐화하여 재사용할 수 있다.
* 적응, 동작, 입력 대화는 정교한 대화를 구현하기 위한 이벤트 중심 디자인이다.
* 스킬 대화는 스킬 컨슈머의 스킬 봇 관리를 자동화한다.

## 적응 대화 상자

적응형 대화는 바로 위에서 이벤트 중심 디자인이라고 했다. 얘는 대화용 이벤트 구동 모델을 사용한다. 

이 대화는 중단 처리, 대화에 인식기(Listener) 연결, 언어 생성 시스템 사용 등 여러 기본 기능을 제공한다.

적응형 대화를 사용하면 대화 모델링에 집중할 수 있고, 매커니즘 자체에는 덜 집중할 수 있다.

적응형 대화는 대화 라이브러리의 일부이고 다른 모든 대화 유형에 사용할 수 있다.

봇이 다음과 같을 때 적응형 대화를 사용하는 것이 좋다.

* 사용자의 입력, 특정 규칙에 따라 대화 분기가 갈리거나(true일땐 뭐하고 false일땐 뭐하고) 반복하는 대화 흐름이 필요한 경우.
* 컨테그트에 따라 조정하거나 임의 순서로 정보를 수락하거나, 한 대화 스레드에서 부수적 대화를 위해 스레드를 일시 중지한 다음 다시 계속할 수 있게 하는 경우
* 컨텍스트별 언어 이해 모델이 필요하거나 사용자 입력에서 엔터티 정보를 추출해야 하는 경우
* 사용자 지정 입력 처리 또는 응답 생성을 활용하는 경우

적응형 대화는 언어 인식 및 언어 생성 지원, 트리거 및 동작을 사용하여 대화 흐름 모델링 및 메모리 범위에 대한 액세스 등의 기능을 지원한다.

## 대화 및 관련 구성 요소

대화 라이브러리에는 대화를 더 유용하게 만들기 위해 몇 가지의 구성 요소가 추가되어있다.

"대화 세트", "대화 컨텍스트", "대화 결과", "대화 관리자"와 같은 것들이 그 예이다.

* 대화 세트 : 대화의 컬렉션이다. 각 대화 인스턴스는 해당 세트에 고유 ID를 사용해서 대화 세트에 추가된다. 봇에서 이 대화 세트 내의 특정 대화나 프롬프트를 시작하려는 경우 ID를 사용해서 사용할 대화를 설정한다. 적응 및 구성 요소 대화에서는 내부 대화 세트가 포함된다.
* 대화 컨텍스트 : 대화 세트와 관련된 정보가 포함되어 있다. 해당 대화와 상호작용하는 프레임워크 내에서 사용된다. 대화 컨텍스트는 현재 턴 컨텍스트, 부모 대화 및 대화 상태를 포함하여 대화 내에서 정보를 유지하는 메서드를 제공한다. 해당 문자열 ID를 통해 대화 상자를 시작하거나 현재 대화 상자(예: 여러 단계가 있는 폭포 대화 상자)를 계속할 수 있다.
* 대화 결과 : 대화가 종료되면 대화의 결과 저오가 있는 대화 결과를 반환한다. 이 결과는 출하는 메서드가 대화 내에서 발생한 상황을 확인하고, 필요한 경우 정보를 저장하기 위해 반환된다.
* 대화 관리자 : 많은 대화 관리 작업을 자동화한다. 적응형 대화나 적응형 대화를 포함하는 다른 대화를 실행하려면 대화 관리자에서 대화를 시작해야 한다.

## Dialog 상태

대화는 멀티턴(multi-turn) 대화나 이와 비슷한 대화를 구현하는 방법이어서 여러 차례 대화를 주고 받는 상황에서도 상태가 지속되어야 한다.

대화에 상태가 없으면 대화 내의 위치나 이미 수집된 정보를 인식할 수 없다.

대화 기반 봇은 대화 세트 컬렉션을 봇을 구현하는 코드에서 멤버 변수로 가질 수 있다.
이 대화 세트는 접근자(상태에 대한 액세스를 제공하는 애)에 대한 핸들을 사용하여 만든다.

봇의 OnTurn 처리기에서 봇은 대화 컨텍스트를 반환하는 대화 세트에서 "컨텍스트 만들기"를 호출하여 대화 하위 시스템을 초기화한다.

이 대화 컨텍스트에는 대화에 필요한 정보가 포함되어 있다.

대화 컨텍스트를 만드려면 상태가 필요하고, 이 상태는 대화 세트를 만들 때 생긴 접근자를 이용해서 액세스할 수 있다.

이 접근자를 사용하면 대화 세트에서 적절한 대화 상태를 가져올 수 있다. 

정리하면, 봇에는 대화 세트 컬렉션이 멤버로 존재한다. 대화 세트에는 대화 컨텍스트라는 정보가 있는데, 이 대화 컨텍스트를 만드려면 상태 정보가 필요하다.
이 상태 정보는 대화 세트를 만들 때 생긴 접근자를 이용하여 접근한다는 것이다.

## 대화 유형

![bot-builder-dialog-classes](https://user-images.githubusercontent.com/41438361/87239556-6d167100-c44b-11ea-87a8-025068ade747.png)

대화는 위에 나온 그림처럼 몇 가지 유형으로 구분되어 제공된다.

"프롬프트 대화"는 폭포형 대화에서 사용되도록 설계되었다.

" 동작 및 입력 대화"는 적응형 대화에서 사용할 수 있도록 설계되었다.

"구성 요소 및 적응형 대화"는 '자식'대화 세트를 관리한다.

"스킬 및 QnA Maker 대화"는 스킬 및 QnA Maker 기능을 대화로 묶는다.

### Prompt

프롬프트는 대화 라이브러리 내에 존재하며 사용자에게 정보를 요청하고 응답을 받는 쉬운 방법을 제공한다.

예를 들어 *숫자 프롬프트*의 경우 요청 질문이나 정보를 지정하면 프롬프트에서 자동으로 유효한 숫자 응답을 받았는지 확인한다.

만약 유효하다면 대화를 계속하고, 아닌 경우 메세지를 사용자에게 다시 띄울 수 있다.

프롬프트는 내부적으로 두가지 단계를 수행한다.

1. 프롬프트에서 입력 요청
2. 유효한 값을 반환 or 프롬프트 사용하여 처음부터 시작

프롬프트에는 프롬프트가 호출뢸 때 제공되는 프롬프트 옵션이 있다.

여기에서 프롬프트에 표시할 텍스트, 대답이 유효한지 검사를 했을 때 아니라면 다시 입력을 받을 재시도 프롬프트, 프롬프트에 응답하기 위한 선택활동을 지정할 수 있는 프롬프트 옵션이 있다. 

프롬프트를 만들 때 사용자가 몇가지 유효성 검사를 추가할 수 있다. 

예를 들어서 숫자 프롬프트를 사용하여 사람 인원 수를 가져오라고 했을 때 파티 크기는 2보다 크고 12보다 작아야 한다고 해보자.

프롬프트는 먼저 유효한 숫자를 받았는지 확인한다음, 유효한 숫자가 들어왔을 때 사용자에게 다시 프롬프트 한다.

프롬프트가 완료되면 결과 값을 명시적으로 반환한다. 이 값이 반환되면 프롬프트 유효성 검사와 추가 사용자 지정 유효성 검사를 모두 통과했는지 확인할 수 있다. 

#### 프롬프트 형식

아까 프롬프트는 내부적으로 두단계를 거친다고 했었다. 

기본 프롬프트는 "열" 과 같은 자연어 입력을 숫자로 해석하거나 "내일" 또는 "금요일 10시"와 같은 입력을
날짜 - 시간으로 해석할 수 있다.

prompt|설명|반환
---- | ---- | ---- 
첨부 파일 프롬프트 | 문서 또는 이미지와 같은 하나 이상의 첨부 파일을 요청한다. | 첨부 파일 개체의 컬렉션
선택 항목 프롬프트 | 여러 옵션 중에서 선택하도록 요청한다. | 찾은 선택 항목 개체
확인 프롬프트 | 확인을 요청한다. | bool 값
날짜-시간 프롬프트 | 날짜-시간을 요청한다. | 날짜-시간 확인 개체의 컬렉션
숫자 프롬프트 | 숫자를 요청한다 | 숫자 값
텍스트 프롬프트 | 일반 텍스트 입력을 요청한다. | 문자열

만약 사용자에게 입력을 요청하려면 "텍스트 프롬프트"와 같은 기본 제공 클래스 중 하나를 사용해서 프롬프트를 정의하고, 이를 대화 집합에 추가한다.

프롬프트에는 대화 세트 내에서 고유해야 하는 고정 ID가 있다. 

각 프롬프트에 대해 사용자 지정 유효성 검사기(아까 추가한 사용자 지정 유효성 검사)를 사용할 수 있으며, 일부 프롬프트의 경우 "기본 로켈"을 지정할 수 있다.

#### 프롬프트 로캘

로캘은 언어 / 언어 제품군을 나타내는 2, 3 또는 4개 문자의 ISO 639코드이다.


로캘은 **선택 항목, 확인, 날짜-시간, 숫자** 프롬프트의 언어별 동작을 결정하는데 사용한다.

임의의 사용자 입력에 대해 채널이 사용자의 메세지에서 로캘 속성을 제공한 경우에 해당 로캘이 사용된다.

그렇지 않으면 프롬프트의 생성자를 호출하거나 나중에 설정해서 프롬프트의 "기본 로캘"이 설정되면 이 로캘이 사용된다.

둘다 제공하지 않으면 영어("en-us")가 로캘로 사용된다.


### 폭포 대화

폭포 대화는 사용자로부터 정보를 수집하거나 일련의 작업을 통해 사용자를 안내하는데 사용되는 대화 구현이다.

대화의 각 단계는 "폭포 단계 컨텍스트(step)" 매개 변수를 사용하는 비동기 함수로 구현된다.

각 단계에서 봇은 사용자에게 입력을 프롬프트하고 응답을 기다린 다음 결과를 다음 단계로 전달한다.

첫 번째 함수의 결과가 그 다음 함수에 인수로 전달된다.

![bot-builder-dialog-concept](https://user-images.githubusercontent.com/41438361/87262271-43655480-c4f4-11ea-9813-7a96f94171dc.png)

위의 다이어그램에서는 폭포 단계의 시퀀스와 수행되는 스택 작업을 보여준다. 

폭포 단계 내에서 폭포 대화 컨텍스트는 해당 "폭포 단계 컨텍스트"에 저장된다.

이거는 현재 턴 컨텍스트와 상태에 대한 액세스를 제공하는 대화 컨텍스트랑 비슷하다.

폭포 단계 컨텍스트 개체를 사용해서 폭포 단계에서 설정된 대화 상자와 상호작용한다.


일반적으로 봇의 턴 논리에서 대화 턴 결과의 상태만 확인하면 되지만, 대화의 폭포 단계나 봇의 OnTurn 처리기에서 대화의 반환 값을 처리할 수도 있다.

폭포 단계 내에서 대화 상자는 폭포 단계 컨텍스트의 result 속성에 반환 값을 제공한다.

#### 폭포 단계 컨텍스트 속성

폭포 단계 컨텍스트에 포함되는 속성은 다음과 같다.

* 옵션 : 대화에 대한 입력 정보 포함
* 값 : 컨텍스트에 추가할 수 있는 정보 포함, 후속 단계로 전달된다.
* 결과 : 이전 단계의 결과 포함

또한 net 메서드(C#의 NextAsync)가 동일한 턴 내에서 폭포 대화의 다음 단계로 계속 진행되므로 필요한 경우 봇에서 특정 단계를 건너 뛸 수 있다.

#### 프롬프트 옵션 

아까 위에서 프롬프트에는 프롬프트가 호출될 때 제공되는 프롬프트 옵션이 있다고 했다. 

단계 컨택스트의 "prompt" method의 두 번째 매개 변수는 아래 표와 같은 속성이 있는 "프롬프트 옵션" 개체를 사용한다.

속성 | 설명
----|----
prompt | 사용자 입력을 요청하기 위해 사용자에게 보내는 초기 활동
Retry prompt | 첫 번째 입력의 유효성을 검사하지 않은 경우 사용자에게 보내는 활동
Choices | 선택 항목 프롬프트에서 사용하기 위해 사용자가 선택할 수 있는 선택 항목 목록
Validations | 사용자 지정 유효성 검사기에 사용할 추가 매개 변수
Style | 선택 프롬프트 또는 확인 프롬프트의 선택 항목을 사용자에게 표시하는 방법을 정의

사용자에게 보낼 초기 프롬프트 활동과 사용자 입력의 유효성이 검사되지 않는 경우 다시 시도 프롬프트를 지정해야 한다.

사용자 입력이 유효하지 않으면 다시 시도 프롬프트가 사용자에게 전송된다. 다시 시도를 지정하지 않은 경우 초기 프롬프트가 다시 전송된다. 하지만 유효성 검사기 내에서 활동을 사용자에게 다시 보내는 경우에는 다시 시도 프롬프트가 전송되지 않는다.

#### 프롬프트 유효성 검사

값을 폭포의 다음 단계로 반환하기 전에 프롬프트 응답의 유효성을 검사할 수 있다.

유효성 검사기 함수는 *프롬프트 유효성 검사기 컨텍스트* 매개 변수를 사용하며, 입력이 유효성 검사를 통과하는지 여부를 나타내는 bool값을 반환한다. 프롬프트 유효성 검사기 컨텍스트에 포함되는 속성은 다음과 같다.

속성 | 설명
----|----
컨텍스트 | 봇에 대한 현재 턴 컨텍스트
Recognized | 인식기에서 처리한 사용자 입력에 대한 정보가 포함된 "프롬프트 인식기 결과"이다.
옵션 | 프롬프트를 시작하는 호출에 제공된 "프롬프트 옵션"을 포함한다.

프롬프트 인식기 결과에 포함된느 속성은 다음과 같다.

속성 | 설명
----|----
성공함 | 인식기에서 입력을 구문 분석할 수 있는지 여부를 나타낸다.
값 | 인식기에서 반환하는 값. 필요한 경우 유효성 검사 코드에서 이 값을 수정할 수 있다.

### 구성 요소 대화 

사용자에게 거리, 도시, 우편 번호에 대한 값을 제공하도록 요청하는 주소 대화와 같이 다른 시나리오에서 사용할 재사용 가능한 대화를 작성하려는 경우가 있다.

구성 요소 대화는 큰 대화 세트를 관리가 용이한 더 작은 구성 요소로 분할하여 특정 시나리오를 처리하는 독립적인 대화를 만드는 전략을 제공한다.

이 각 구성 요소에는 자체의 고유한 대화 세트가 있으며, 이 대화 세트가 포함된 대화 세트를 이용하여 이름 충돌을 방지할 수 있다.

## 대화 사용

대화 컨텍스트를 사용하여 대화를 시작, 계속, 대체, 종료할 수 있다. 또한 대화 스택의 모든 대화를 취소할 수도 있다.

대화는 " 대화 스택"이라고 하는 프로그래밍 방식의 스택으로 간주할 수 있다.

한 스택에서 전달하고 스택이 비어 있는 경우 대체 역할을 수행하는 턴 처리기를 사용한다. 해당 스택에서 가장 위쪽에 있는 항목은 "활성 대화"라고 간주하며, 대화 컨텍스트에서 모든 입력을 활성 대화로 전달한다.

대화가 시작되면 스택으로 푸시되며, 바로 활성 대화가 된다.

이는 대화가 종료될때까지 활성 대화로 유지되거나, 대화 대체 method를 통해 제거되거나, 턴 처리기 또는 활성 대화 자체를 통해 다른 대화가 스택에 푸시되어 활성 대화가 된다. 

이 새 대화가 종료되면 스택에서 꺼내고, 밑에 있던 대화가 다시 활성 대화가 된다.

이렇게 하면 대화 상자 반복 또는 대화 분기가 허용된다.

### 대화 컨텍스트 만들기

대화 컨텍스트를 만드려면 대화 세트의 "컨텍스트 만들기" 메서드를 호출한다.

컨텍스트 만들기는 대화 세트의 "대화 상태" 속성을 가져오고 이 속성을 사용하여 대화 컨텍스트를 만든다. 그러면 대화 컨텍스트를 사용하여 세트의 대화를 시작, 이어가기, 또는 제어한다.

대화 상태에 액세스하려면 대화 세트에서 "상태 속성 접근자"를 사용해야 한다. 접근자는 다른 상태 접근자와 동일한 방식으로 만들어지고 사용되지만, 대화 상태에 기반한 자체 속성으로 만들어진다. 

### 대화 상자를 시작하려면

대화를 시작하기 위해서는 시작하려는 대화ID를 대화 컨텍스트의 "대화 시작", "프롬프트" 또는 대화 대체 메서드로 전달한다.

* 시작 대화 상자 메서드는 스택의 맨 위에 대화 상자를 푸시한다.
* 대체 대화 상자 메서드는 현재 대화 상자를 스택에서 삭제하고 대화 대촤 상자를 스택 위로 푸시한다. 대체된 대화 상자는 취소되고 인스턴스에 포함된 모든 정보는 삭제된다.

"options" 매개 변수를 사용해서 대화 상자의 새 인스턴스로 정보를 전달한다. 새 대화 상자에 전달된 option은 대화 상자의 어느 단계에서든 단계 컨택스트의 options 속성을 통해 액세스할 수 있다.

### 대화를 계속하려면

대화를 계속하려면 "대화 계속" 메서드를 호출한다. 스택의 맨 위에 있는 대화(활성 대화)가 있는 경우 계속 메서드에서 항상 해당 메서드를 계속한다.

계속된 대화가 종료되면 제어가 동일한 턴 내에서 계속되는 부모 컨텍스트로 전달된다.

단계 컨택스트의 value 속성을 사용하여 턴 사이의 상태를 유지한다. 이전 턴에서 이 컬랙션에 추가된 모든 값을 후속 턴에서 사용할 수 있다. 

### 모든 대화를 지우려면

모든 대화 상자를 스택에서 삭제하려면 대화 상자 컨텍스트의 cancel all dialogs 메서드를 호출하여 대화 상자 스택을 지울 수 있다.

### 대화 상자 반복

대화 바꾸기 메서드를 사용하여 대화를 자체적으로 바꿔 루프를 만들 수 있다. 이는 복잡한 반복을 처리하는 좋은 방법이며, 메뉴를 관리하는 데 유용한 기술이다.

현재 대화에 대한 내부 상태를 유지해야 하는 경우 대화 대체 메서드 호출에서 대화의 새 인스턴스로 정보를 전달한 다음, 대화를 적절히 초기화해야 한다.

### 대화 분기

대화 컨텍스트는 대화 스택을 유지하고 스택의 각 대화에 대한 다음 단계를 추적한다. 대화의 "대화 시작" 메서드는 자식 대화를 만들어 해당 대화를 스택의 맨 위로 푸시하고, "대화 종료" 메서드는 스택에서 맨 위의 대화를 꺼낸다. "대화 종료"는 일반적으로 종료되는 대화 내에서 호출된다.

대화 상자는 대화 상자 컨텍스트의 begin dialog 메서드를 호출하고, 새 대화 상자가 현재 활성 대화 상자가 되도록 새 대화 상자의 ID를 제공해서 동일한 대화 상자 집합 내에서 새 대화 상자를 시작할 수 있다.

원래 대화 상자는 여전히 스택에 있지만, 대화 상자 컨텍스트의 continue dialog 메서드에 대한 호출은 스택 맨 위에 있는 대화 상자인 활성 대화 상자한테만 전송된다. 대화 상자가 스택에서 사라지면 대화 상자 컨택스트가 원래 대화 상자에서 사라졌던 스택에서 폭포의 다음 단계로 다시 시작된다.

따라서 사용 가능한 대화 상자 집합에서 시작할 대화 상자를 조건부로 선택할 수 있는 단계를 하나의 대화 상자에 포함하여 대화 흐름 내에 분기를 만들 수 있다. 


