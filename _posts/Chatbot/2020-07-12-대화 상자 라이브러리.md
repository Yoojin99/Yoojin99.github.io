---
title:  "Chatbot - 대화 상자 라이브러리"
excerpt: "Chatbot - 대화 상자 라이브러리"

toc: true
toc_sticky: true
toc_label: "페이지 주요 목차"
header:
  teaser: 
  
  
categories:
  - Chatbot
  
tags:
  - Chatbot
  - 공부
  - Azure
last_modified_at: 
---

대화 상자 라이브러리
====================

대화는 SDK 의 핵심 개념이다. 대화는 사용자와 대화를 관리하는 방법을 제공하나.

대화는 봇의 프로그램에서 함수처럼 작동하는 봇의 구조이다.

각 대화는 특정 작업을 수행하도록 되어있다. 

대화는 순서를 지정해서 대화를 안내하거나(다중 연결 대화와 같은 것을 말하는 것 같다), 사용자에게 응답하거나 등등 다양한 방식으로 호출된다.

대화 라이브러리는 대화를 더 쉽게 관리하기 위해 몇 기본 제공 대화 유형을 제공한다.

* 폭포/프롬프트 대화는 여러 대화 단계를 결합하여 특정 시퀀스를 따르게 항 정보를 한 단계에서 그 다음 단계로 전달될 수 있게 한다.
* 구성 요소 대화를 사용하면 선물세트처럼 대화 세트를 캡슐화하여 재사용할 수 있다.
* 적응, 동작, 입력 대화는 정교한 대화를 구현하기 위한 이벤트 중심 디자인이다.
* 스킬 대화는 스킬 컨슈머의 스킬 봇 관리를 자동화한다.

## 적응 대화 상자

적응형 대화는 바로 위에서 이벤트 중심 디자인이라고 했다. 얘는 대화용 이벤트 구동 모델을 사용한다. 

이 대화는 중단 처리, 대화에 인식기(Listener) 연결, 언어 생성 시스템 사용 등 여러 기본 기능을 제공한다.

적응형 대화를 사용하면 대화 모델링에 집중할 수 있고, 매커니즘 자체에는 덜 집중할 수 있다.

적응형 대화는 대화 라이브러리의 일부이고 다른 모든 대화 유형에 사용할 수 있다.

봇이 다음과 같을 때 적응형 대화를 사용하는 것이 좋다.

* 사용자의 입력, 특정 규칙에 따라 대화 분기가 갈리거나(true일땐 뭐하고 false일땐 뭐하고) 반복하는 대화 흐름이 필요한 경우.
* 컨테그트에 따라 조정하거나 임의 순서로 정보를 수락하거나, 한 대화 스레드에서 부수적 대화를 위해 스레드를 일시 중지한 다음 다시 계속할 수 있게 하는 경우
* 컨텍스트별 언어 이해 모델이 필요하거나 사용자 입력에서 엔터티 정보를 추출해야 하는 경우
* 사용자 지정 입력 처리 또는 응답 생성을 활용하는 경우

적응형 대화는 언어 인식 및 언어 생성 지원, 트리거 및 동작을 사용하여 대화 흐름 모델링 및 메모리 범위에 대한 액세스 등의 기능을 지원한다.

## 대화 및 관련 구성 요소

대화 라이브러리에는 대화를 더 유용하게 만들기 위해 몇 가지의 구성 요소가 추가되어있다.

"대화 세트", "대화 컨텍스트", "대화 결과", "대화 관리자"와 같은 것들이 그 예이다.

* 대화 세트 : 대화의 컬렉션이다. 각 대화 인스턴스는 해당 세트에 고유 ID를 사용해서 대화 세트에 추가된다. 봇에서 이 대화 세트 내의 특정 대화나 프롬프트를 시작하려는 경우 ID를 사용해서 사용할 대화를 설정한다. 적응 및 구성 요소 대화에서는 내부 대화 세트가 포함된다.
* 대화 컨텍스트 : 대화 세트와 관련된 정보가 포함되어 있다. 해당 대화와 상호작용하는 프레임워크 내에서 사용된다. 대화 컨텍스트는 현재 턴 컨텍스트, 부모 대화 및 대화 상태를 포함하여 대화 내에서 정보를 유지하는 메서드를 제공한다. 해당 문자열 ID를 통해 대화 상자를 시작하거나 현재 대화 상자(예: 여러 단계가 있는 폭포 대화 상자)를 계속할 수 있다.
* 대화 결과 : 대화가 종료되면 대화의 결과 저오가 있는 대화 결과를 반환한다. 이 결과는 출하는 메서드가 대화 내에서 발생한 상황을 확인하고, 필요한 경우 정보를 저장하기 위해 반환된다.
* 대화 관리자 : 많은 대화 관리 작업을 자동화한다. 적응형 대화나 적응형 대화를 포함하는 다른 대화를 실행하려면 대화 관리자에서 대화를 시작해야 한다.

## Dialog 상태

대화는 멀티턴(multi-turn) 대화나 이와 비슷한 대화를 구현하는 방법이어서 여러 차례 대화를 주고 받는 상황에서도 상태가 지속되어야 한다.

대화에 상태가 없으면 대화 내의 위치나 이미 수집된 정보를 인식할 수 없다.

대화 기반 봇은 대화 세트 컬렉션을 봇을 구현하는 코드에서 멤버 변수로 가질 수 있다.
이 대화 세트는 접근자(상태에 대한 액세스를 제공하는 애)에 대한 핸들을 사용하여 만든다.

봇의 OnTurn 처리기에서 봇은 대화 컨텍스트를 반환하는 대화 세트에서 "컨텍스트 만들기"를 호출하여 대화 하위 시스템을 초기화한다.

이 대화 컨텍스트에는 대화에 필요한 정보가 포함되어 있다.

대화 컨텍스트를 만드려면 상태가 필요하고, 이 상태는 대화 세트를 만들 때 생긴 접근자를 이용해서 액세스할 수 있다.

이 접근자를 사용하면 대화 세트에서 적절한 대화 상태를 가져올 수 있다. 

정리하면, 봇에는 대화 세트 컬렉션이 멤버로 존재한다. 대화 세트에는 대화 컨텍스트라는 정보가 있는데, 이 대화 컨텍스트를 만드려면 상태 정보가 필요하다.
이 상태 정보는 대화 세트를 만들 때 생긴 접근자를 이용하여 접근한다는 것이다.

## 대화 유형

![bot-builder-dialog-classes](https://user-images.githubusercontent.com/41438361/87239556-6d167100-c44b-11ea-87a8-025068ade747.png)

대화는 위에 나온 그림처럼 몇 가지 유형으로 구분되어 제공된다.

"프롬프트 대화"는 폭포형 대화에서 사용되도록 설계되었다.

" 동작 및 입력 대화"는 적응형 대화에서 사용할 수 있도록 설계되었다.

"구성 요소 및 적응형 대화"는 '자식'대화 세트를 관리한다.

"스킬 및 QnA Maker 대화"는 스킬 및 QnA Maker 기능을 대화로 묶는다.

## Prompt

프롬프트는 대화 라이브러리 내에 존재하며 사용자에게 정보를 요청하고 응답을 받는 쉬운 방법을 제고안다.

예를 들어 *숫자 프롬프트*의 경우 요청 질문이나 정보를 지정하면 프롬프트에서 자동으로 유효한 숫자 응답을 받았는지 확인한다.

만약 유효하다면 대화를 계속하고, 아닌 경우 메세지를 사용자에게 다시 띄울 수 있다.

프롬프트는 내부적으로 두가지 단계를 수행한다.

1. 프롬프트에서 입력 요청
2. 유효한 값을 반환 or 프롬프트 사용하여 처음부터 시작

프롬프트에는 프롬프트가 호추뢸 때 제공되는 프롬프트 옵션이 있다.

여기에서 프롬프트에 표시할 텍스트
