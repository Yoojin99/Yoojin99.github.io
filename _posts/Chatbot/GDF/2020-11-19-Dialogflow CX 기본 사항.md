---
title:  "GDF - Dialogflow CX 기본사항"
excerpt: ""

toc: true
toc_sticky: true
toc_label: "페이지 주요 목차"
header:
  teaser: 
  
  
categories:
  - Chatbot
  
tags:
  - Chatbot
  - GDF
last_modified_at: 2020-11-19
---

[링크](https://cloud.google.com/dialogflow/cx/docs/basics)

## 에이전트

Dialogflow CX 에이전트는 끝단의 사용자와의 대화를 처리하는 가상 에이전트이다. 이것은 인간 언어의 미묘한 차이를 이해하는 자연어 이해 모듈이다.
Dialogflow는 대화로 이루어진 사용자의 텍스트나 오디오를 앱과 서비스가 이해할 수 있는 구조화된 데이터로 변환한다. 시스템에 필요한 대화 유형을 처리하도록 Dialogflow
에이전트를 직접 설계하고 빌드할 수 있다. 이거는 MS chatbot과 다름이 없어보인다.

Dialogflow 에이전트는 콜센터 상담원과 비슷하다. 둘 다 예상되는 대화 시나리오를 처리하도록 학습해야 하며, 학습이 지나치게 명시적일 필요는 없다.
즉 대화 플로우(다이얼로그)는 정의해놓긴 하되 자연어 처리 학습을 통해 우리가 잘 해줄테니까 너무 명시적으로 대화를 정의하지는 말아라 이소리 같기는 하다.

## 흐름

복잡한 대화상자에는 여러 가지 대화 주제가 포함되는 경우가 많다.(다이얼로그를 여러개 가질 수 있다.) 피자 배달 에이전트는 음식 주문, 고객 정보, 확인을 별도의 다이얼로그로 가질 수 있다.
각 주제마다 에이전트가 끝단의 사용자에세 정보를 얻기 위해서는 여러 번 번갈아가며 대화를 해야 한다. 아마 flow는 ms chatbot을 개발할 때 사용했던 step과 비슷한 개념인 것 같다.

흐름(Flow)는 이런 주제와 연결된 대화 경로를 정의하는 데 사용된다. 모든 에이전트에는 **기본 시작 흐름**이라는 흐름이 있다. 간단한 에이전트는 이 단일 흐름만 사용할 수도 있다.
복잡한 에이전트에는 추가적으로 flow가 더 많이 필요할 수 있으며, 이런 흐름을 빌드하고 유지 관리할 수 있다. 흐름은 추가 비용을 요구하지 않는다.

## 페이지

Dialogflow CX 대화(세션)을 상태 머신으로 설명하고 시각화할 수 있다. CX 세션의 상태는 페이지로 표시할 수 있다.

각 흐름에 대해 여러 페이지를 정의하면 조합된 페이지에서 흐름이 설계된 주제에 대한 완전한 대화를 처리할 수 있다. 특정 시점에 정확히 하나의 페이지는 현재 페이지이고, 
현재 페이지는 활성 페이지로 간주되고, 해당 페이지와 연결된 흐름은 활성으로 간주한다. 모든 흐름에는 특수한 시작 페이지가 있다. 

처음에 흐름이 활성화되면 시작 페이지가 현재 페이지가 된다. 각 대화 차례에서 현재 페이지는 동일하게 유지되거나 다른 페이지로 전환된다. 아마 페이지가 다이얼로그의 개념일 것 같다.

페이지가 나타내는 대화 상태와 관련된 정보를 사용자로부터 수집하도록 각 페이지를 구성한다. 즉 여러 흐름들로 페이지를 구성하라는 것 같다.

## 항목 유형(Entity types)

(원래 한국어 버전의 문서가 있는데, 너무 번역기로 돌린 것 같아 내가 그냥 번역했다.) 

Entity type은 끝단 사용자의 입력에서 어떻게 데이터가 추출되는지 제어하기 위해 사용된다. CX entity type은  ES entity type과 굉장히 유사하다.

Dialogflow는 다양한 일반적인 타입의 데이터에 맞출 수 있는 미리 정의된 시스템 엔티티를 사용한다. 예를 들어, 날짜, 시간, 색, 이메일 주소에 맞출 수 있는
시스템 엔티티들이 있다. 또한 커스텀한 데이터에 맞는 자신만의 커스텀데이터를 만들수도 있다. 예를 들어, 채소 가게 에이전트에서 결제를 할 수 있게 야채의 종류에 맞는 야채 엔티티를
만들 수도 있다.

## Parameters

Patameter는 한 세션에서 사용자가 제공한 값들을 캡쳐하고 참조하기 위해 사용된다. 각 파라미터들은 이름을 가지고 있고 얘네들은 각각 엔티티 타입이다. 날 것의 사용자 입력과는 달리,
파라미터들은 특정 로직을 수행하거나 일반적인 응답에 쉽게 사용할 수 있도록 구조화된 데이터들이다.

CX 파라미터들은 ES 파라미터와 비슷하지만, 성능과 스코프가 확장되었고, 파라미터를 참조하는 문법이 바뀌었다. 

## Forms

각 페이지마다 페이지에서 사용자들에게서 받아야 하는 파라미터의 리스트인 form을 정의할 수 있다. Agent는 모든 요구되는 page parameter라고 알려진 form parameter
들을 모두 가져오기 전까지 사용자와 상호작용한다. 각 form parameter들에 대해, 당신은 그 정보를 사용자에게 요청하기 위해 에이전트가 사용할 prompt를 제공할 수 있다.
이 프로세스는 form filling이라 불린다.

예를 들어, `Collect Customer Info` 페이지를 위한 사용자 이름과 전화번호를 받는 form을 만들 수 있다.

## Intents

Intent는 한 대화 턴에서 사용자의 의도를 카테고리화 한다. ES intent과는 다르게, CX intent는 그것을 더 재사용이 가능한 리소스로 만들 수 있게 단순해졌다.

intent는 아래의 데이터를 포함한다. (약간 QnA Maker와 비슷한 것 같다)

|training phrases|트레이닝 문구는 사용자가 입력하거나 말하는 것- 즉 end-user input의 예시 문구이다. 이 중 하나를 사용자가 말할 경우, Dialogflow는 intent와 매칭시킨다. 물론 이걸 가능한 모든 답변을 정의할 필요는 없다. 왜냐하면 Dialogflow안에 내장된 머신 러닝이 비슷한 답변들을 매칭시켜줄 것이기 때문이다.|
|Parameters|사용자의 입력의 특정한 부분에서 값들을 추출하기 위한 파라미터를 사용하기 위해 training 문구를 정의한다.|

## Webhook

Webhook은 비즈니스 로직을 운영하는 서비스이다. 세션 중에, 웹훅은 다양한 답변과 추출된 유효한 데이터, 혹은 백엔드에서 특정 행동을 실행시키기 위한 다이얼로그 플로우의
자연어처리 프로세싱에 의해 추출된 데이터를 사용하게 해준다.

## Fulfillment

에이전트의 대화 턴에서 에이전트는 질문을 하거나, 정보에 대한 쿼리를 하거나, 세션을 종료하기 위해 사용자에게 응답을 해야 한다. 에이전트는 다양한 응답을 생성하거나 
특정 행동을 하기 위해 서비스와 연결해야 할 수도 있다. Fulfillment는 이 모든 것을 가능하게 하기 위해 사용된다.

Fulfillment는 다음의 것을 포함할 수 있다:

* 정적 응답 메시지
* 다양한 응답/액션을 하기 위한 웹훅 call
* 파라미터 값들을 덮어쓰거나 설정하기 위한 파라미터 프리셋

Agent의 턴에서, 각각 응답 메세지를 만들 수 있는 fulfillment들을 여러개 부를 수 있다(어떤 때는 이것을 하는 것이 필수적일 수 있다). Dialogflow는 이 응답들을 response queue에 유지한다. Agent의 턴이 끝나면, Dialogflow는 이 정렬된 응답들을 사용자에게 보낸다.









