---
title:  "총정리"
excerpt: ""

toc: true
toc_sticky: true
toc_label: "페이지 주요 목차"
header:
  teaser: 
  
  
categories:
  - soso
  
tags:
  - 총정리
last_modified_at: 2020-11-22
---

## 컴네

### OSI 7계층

나누는 이유 : 문제가 발생한 부분만 고치면 되고, 통신이 일어나는 과정을 단계별로 알 수 있습니다.

1. 물리 : 데이터를 전기적 신호로 변환해서 전송함 - 케이블, 허브
2. data-link : 물리 계층으로 전송하는 정보를 관리합니다. 에러검출, 재전송, 흐름제어. Mac 주소 통해. - 브릿지, 스위치
3. network : 라우터를 통해 IP 주소를 지정해서 경로를 따라 데이터를 목적지까지 전송합니다. 라우팅, 흐름제어, 오류제어 - 라우터 IP - 
4. transport : TCP, UDP 프로토콜을 이용해서 통신을 활성화시킵니다. TCP:신뢰성, 연결지향적, UDP : 비신뢰성, 비연결성, 실시간
5. session : 데이터가 통신하기 위한 논리적 연결을 담당합니다. TCP/IP 세션을 만들고 없앱니다. - API, Socket
6. presentation : 데이터 표현에 대한 독립성을 제공하고 암호화합니다. JPEG, MPEG
7. application : 응용 서비스를 수행합니다. - HTTP, DNS, FTP

### TCP

신뢰성 있는 연결을 보장해주는 프로토콜입니다.

* 3-way handshaking

  1. 클라이언트가 서버에 syn 패킷을 보냅니다.
  2. 서버가 잘 받았다는 ack 패킷과 syn 패킷을 보냅니다.
  3. 클라이언트가 잘 받았다는 ack 패킷을 보냅니다.

* 4-way handshaking
  
  1. 클라이언트가 연결 종료하겠다는 fin 플래그를 보냅니다.
  2. 서버는 잘 받았다는 ack 패킷을 보냅니다. 이때 데이터를 모두 보내기 위해 timeout이 됩니다.
  3. 데이터를 다 보내면 fin 플래그를 보냅니다.
  4. 클라는 fin을 받고 확인했다는 ack을 다시 서버에 보냅니다. time wait을 통해 더 받을 데이터가 있는지 기다립니다.
  

### UDP

비신뢰성, 비연결성 성격을 띄는 프로토콜입니다.

1. IP는 장치간의 전송만을 해주고, 장치 안에 여러프로그램이 있을 경우 프로그램으로 전달은 못 시켜줍니다. -> port number
2. IP에서 발생한 오류를 윗단에서 처리해 줘야 하기 때문에 TCP UDP 프로토콜이 등장했습니다.

TCP는 손실, 순서바뀜, 중복을 보정해서 데이터가 정상적으로 전송될 수 있게 한다.
UDP는 IP단에서 하는 정도로만 해주기 때문에 오류가 발생할 수도 있습니다.

UDP는 대신 데이터의 처리 속도가 빠릅니다. 실시간 방송 / 온라인 게임에서 사용됩니다.

DNS는 UDP를 사용합니다.

1. 3 way handshaking으로 연결을 유지할 필요가 없습니다.
2. DNS request는 UDP segment에 들어갈 수 있을 정도로 작습니다.
3. UDP 자체는 안정성이 보장되어 있지 않지만, application 계층에서 추가될 수 있습니다.

### TCP 흐름제어 / 혼잡제어

TCP : 신뢰성 있는 연결을 보장하는 프로토콜입니다.

해결해야 하는 문제는 4가지로, 1. 손실 2. 순서바뀜 3. congestion 4. overload

1. 흐름제어 : 송신자와 수신자의 데이터 처리 속도간의 차이가 나서 발생하는 문제를 해결합니다.
  1. stop and wait : 수신자가 잘 받았다는 응답을 받아야만 다음 패킷을 전송합니다.
  2. sliding window : 수신자가 정한 윈도우 크기만큼 패킷을 보내고, 전달이 확인되는 대로 윈도우를 옆으로 옮겨서 다음 패킷들을 전송하는 것입니다.
2. 혼잡제어 : NW 상에 packet이 과도하게 많아지는 것을 예방합니다.
  1. AIMD : 처음에 패킷을 하나씩 보내고 이후 1씩 패킷 수를 증가하여 전송. 패킷 전송에 문제가 생기면 반으로 다시 줄여 보냅니다.
    초기 네트워크 대역폭을 이용하지 못하고, 혼잡 상황을 미리 감지하지 못합니다.
  2. Slow start : 초기에 2배씩 늘리다가 혼잡해지면 1로 감소시켜 다시 2배씩 올립니다. 혼잡 상황이 발생하면 수용량을 예측해서 혼잡 상황이 발생했을때의 패킷수의 절반까지는 2배씩 올리고 이후는 1씩 올립니다.
  3. 빠른 재전송 : 중복된 순번의 패킷을 3개 받으면 재전송을 하는 것입니다. 혼잡상황을 감지하고 윈도우 사이즈를 줄입니다.
  4. 빠른 회복 : 혼잡상황이 되면 윈도우를 1로 줄이지 않고 반으로 줄여 선형증가를 시키는 방법입니다.

### 대칭키&공개키

1. 대칭키
  동일한 키를 갖고 암호화와 복호화를 하기 때문에 빠르지만, 해킹 위험이 있습니다.
2. 공개키
  개인키로만 복호화 할 수 있는 키로, 공개하는 키를 의미합니다.
  
* 공개키 암호화 방식
  1. A가 B의 공개키를 이용해 암호화해서 b에 보냅니다.
  2. B는 자신의 비밀키로 복호화하고, A의 공개키로 응답을 암호화해서 보냅니다.
  3. A는 자신의 비밀키로 복호화합니다.
  
* 대칭키 + 공개키 암호화
  모두 사용할 대칭키 자체를 암호화 하는 것입니다.
  
  1. A가 B의 공개키로 대칭키를 암호화 해서 B에 보냅니다.
  2. B는 자신의 개인키로 복호화해서 대칭키를 갖습니다.
  3. 대칭키로 암호화하여 A에 보냅니다.
  4. A는 자신의 개인키로 암호문을 복호화합니다.

### HTTP & HTTPS

1. HTTP : 인터넷 상에서 클라이언트와 서버가 정보를 주고 받을 때 사용하는 통신 규약입니다. 텍스트여서 보안 문제가 존재합니다.
2. HTTPS : 정보를 암호화하는 SSL 프로토콜을 이용하는 정보를 주고받을 때 사용하는 통신 규약입니다. 텍스트를 암호화합니다.

HTTPS 통신 방식

1. A가 CA에 인증서를 요청합니다. 
2. CA가 개인키로 암호화해서 A에 전달합니다.
3. 클라이언트가 https가 아닌 요청을 a에 할 때, 클라이언트는 인증서를 받습니다.
4. ca의 공개키로 인증서를 복호화해서 a의 공개키를 얻습니다. a의 공캐키로 암호화해서 요청을 다시 날립니다.

### 로드 밸런싱

둘 이상의 CPU나 저장장치와 같은 컴퓨터 자원에게 작업을 나누는 것입니다.

트래픽이 많아지면서 1대의 서버로는 부족하게 되었습니다.

1. Scale up : 하드웨어의 성능을 높입니다. 비쌉니다.
2. Scale out : 여러대의 서버가 나눠서 일하게 합니다. 효과적입니다.

여러 서버에 균등하게 트래픽을 분산시켜주는 것이 로드 밸런싱입니다. 분산식 웹 서비스.

로드 밸런서는 여러 서버에 트래픽을 분산하는 애입니다. 이 서버를 선택하는 방법은 다음과 같습니다.

* 라운드 로빈
* least connections
* source : 사용자 IP를 해싱하여 분배

이 로드 밸런서도 문제가 생길 수 있기 때문에 로드 밸런서를 이중화하여 대비합니다.

### GET POST

* GET : 요청하는 데이터가 url 주소에 붙여져서 전송되는 것입니다. 보안적으로 문제가 있고, 전송할 수 있는 데이터의 양이 제한적입니다.
* POST : 메세지의 바디 부분에 데이터가 담겨서 전송되는 것입니다. 데이터를 상대적으로 더 많이, 안전하게 보낼 수 있습니다. 

Get은 서버에서 어떤 데이터를 가져와서 보여주고, 서버의 값이나 상태를 변경하지 않습니다.

Post는 서버의 값이나 상태를 변경하기 위해 사용됩니다. 

## OS

### 프로세스 / 스레드

* 프로세스 : 프로그램이 실행되기 위해서 자원이 필요한데, 이 자원을 할당받는 작업의 단위입니다.
* 스레드 : 프롯세스 내에서 독립적인 실행 흐름을 갖고 있는, 자원의 운용 단위입니다.

* 프로세스 제어 블록(PCB) : 특정 프로세스에 대한 중요한 정보를 저장합니다. 문맥 교환이 일어났을 때 진행 상황을 저장하고 다시 CPU의 자원을 할당받으면 PCB에 있던 내용을 불러옵니다.

PCB에는 

1. PID : 식별자
2. 프로세스 상태
3. PC

등등을 저장합니다.

스레드는 프로세스의 힙, 데이터, 코드 영역을 공유하고, 스택을 독립적으로 갖습니다. 독립적인 실행흐름을 갖기 위해서는 각각 다른 반환 주소를 갖고 있어야 가능한데, 스택은 함수 호출시 전달되는 인자, 되돌아갈 주소 값을 저장할 수 있는 공간이기 떄문입니다.
PC 레지스터도 마찬가지입니다. PC는 프로그램이 현재 어디까지 수행되었는지를 보여주기 때문에 스레드가 이를 독립적으로 갖습니다. 

### 멀티 스레드

* 장점
  멀티 스레드를 하면 멀티 프로세싱에 비해 메모리와 자원의 소모를 아낄 수 있습니다. 문맥교환이 일어날때 멀티 프로세싱에서는 캐시에 있는 내용을 모두 플러시해야 하는데, 스레드는 그럴 필요가 없습니다.
  스레드간의 통신이 필요한 경우에는 전역 변수, 동적 할당 공간인 힙 영역을 이용해서 데이터를 주고 받습니다.

* 단점
  구현이 복잡하고 공유 자원에 대한 관리가 어렵습니다. 따라서 동기화 작업이 필요합니다. 동기화 작업을 통해 자원에 접근을 컨트롤 할 수 있습니다.
  하나의 스레드가 문제가 생기면 다른 스레드들에도 영향을 끼칩니다.
  
### 스케줄러

프로세스를 스케줄링 하기 위한 큐에는 세가지가 존재합니다.

* Job 큐 : 현재 시스템에 존재하는 모든 프로세스
* 레디 큐 : CPU의 자원을 잡아 실행을 하기 위해 기다리는 애들의 집합
* 디바이스 큐 : I/O 작업을 대기하고 있는 애들의 집합

이런 큐에 프로세스를 넣고 빼는 스케줄러도 세가지가 존재합니다.

1. 장기 스케줄러 : 메모리를 할당해서 레디 큐에 보낼 프로세스를 결정합니다. 실행중인 프로세스의 수를 제어합니다. 메모리-디스크
2. 단기 스케줄러 : CPU-메모리 스케줄링 담당. 레디->러닝 시킬 프로세스를 결정합니다.
3. 중기 스케줄러 : 여유공간 확보를 위해 메모리에서 디스크로 프로세스를 swap out 시키는 것입니다. 얘도 실행중인 프로세스의 수를 조정합니다.

suspended : 프로세스가 디스크로 전부 쫓겨난 것을 말합니다. 외부에서 다시 불러줘야 돌아갈 수 있습니다.

### CPU 스케줄러

1. FCFS - 비선점형. convey effect: 너무 긴 실행시간 갖는 애가 먼저 도착
2. SJF - 비선점형. starvation 문제가 발생할 수 있습니다.
3. SRT - 선점형. 현재 수행중인 프로세스의 남은 실행시간보다 더 적은 실행시간을 갖는 애가 도착하면 뺏습니다. starvation.
4. 우선순위 : 우선순위가 높은 애한테 CPU를 할당합니다. 선점형, 비선점형 모두 가능합니다. starvation. 해결책은 aging입니다. 
5. RR : 동일한 할당 시간을 갖습니다. 가능한 이유는 context save가 가능하기 떄문입니다. 응답시간이 빨라지는 장점이 있습니다. (n-1)q 시간 이상 기다리지 않습니다.

### 동기 / 비동기

* 동기는 특정 작업이 끝날때까지 기다리고, 그동안 프로그램은 실행시키지 않습니다. 결과가 반환되면 이어서 프로그램을 실행시킵니다.
* 비동기는 특정 작업의 결과물이 나올때까지 기다리지 않고 이어서 프로그램을 계속 실행시키는 것입니다. 이때 백그라운드 스레드에서 이 task를 위임하고 바로 다음 코드를 실행시킵니다.

### 프로세스 동기화

* critical section : 공유 자원에 접근해서 코드를 실행시키는 부분의 영역을 말합니다.

문제 해결을 위한 조건

1. 상호배제 : 한 애가 critical section을 실행중이라면 다른 애들은 거기에서 실행시킬 수 없습니다.
2. 진행 : critical section에서 실행중인 애가 없고 별도의 동작이 없는 애들만 진입 후보가 될 수 있습니다.
3. 한정 대기: 한 애가 진입 후보가 되고 나서 다른 애들이 진입하는 횟수에는 제한이 있어야 합니다.

해결책

1. Lock : critical section에 동시접근하는 것을 막습니다.
2. 세마포어
  1. 카운팅 세마포어 : 가용 자원의 개수를 세고 접근을 관리하는 용입니다. 
  2. 이진 세마포어
  
단점

1. Busy waiting : critical section에 들어가기 위한 진입 코드를 계속 실행시킨 상태로 대기합니다. CPU를 낭비합니다.
2. Deadlock : 둘 이상의 프로세스가 critical section에 진입을 무한정 기다리는 상태.

* 모니터 : 자동으로 프로세스가 상호배제가 되게 하는 데이터 형태입니다. 공유 자원에 접근하기 위한 키 획득과 자원 사용 후 해제를 모두 처리합니다.

### 메모리 관리 배경

프로세스는 각각마다 독립된 메모리 공간을 갖습니다. 

* Fragmentation : 프로세스들이 사용하지 못하는 메모리 영역을 가리킵니다.
  1. 외부 조각 : 공간이 있지만 작아서 사용하지 못하느 현상
  2. 내부 조각 : 남은 공간에 프로세스가 들어가고도 남아서 발생하는 부분입니다.
  
이를 압축으로 해결할 수 있지만 효율성에서 문제가 생깁니다. (한쪽으로 프로세스를 다 밀어서 여유 공간을 많이 만드느 것입니다.)

1. 페이징 : 메모리 공간에 프로세스가 연속적으로 올라가야 한다는 제약을 없앴습니다. 프레임 단위로 물리 메모리를 나누고, 논리 메모리를 페이지 단위로 나눈 것입니다. 내부조각 문제가 생깁니다.
2. segmentation : 크기를 정해 나누지 않고 의미 단위로 나누는 것입니다. 외부 조각이 생길 수 있습니다.

### 가상 메모리

다중 프로그래밍을 하기 위해서는 프로세스를 동시에 메모리에 많이 올려야 합니다. 가상 메모리는 프로세스 전체가 메모리에 올라오지 않더라도 실행이 가능하게 합니다.

* demand paging : 프로그램 실행 시작 시에 필요한 애들만 물리적 메모리에 올리는 것을 말합니다. 한 번도 접근되지 않은 페이지는 물리적 메모리에 올라가지 않습니다. 사용되지 않는 애들을 가져오는 시간낭비와 메모리 낭비를 줄일 수 있습니다.

* 페이지 교체 : page fault가 발생하면 보조 저장장치에서 페이지를 가져오거나 내쫓는것.

1. FIFO : 처음부터 활발한 페이지를 내쫓을 수 있습니다. belady의 모순 : 프레임 갯수를 늘려도 부재가 더 많이 발생합니다.
2. Opt : 실제 구현 어렵.
3. LRU
4. LFU

### IPC

프로세스는 독립적으로 실행됩니다. 독립적인 프로세스간의 통신을 할 수 있는 방법은 다음과 같습니다.

1. 익명 pipe : 한쪽 방향으로만 통신이 가능합니다. 한쪽은 쓰고, 한쪽은 읽기만 합니다.
2. message queue : 사용할 데이터에 번호를 붙여서 여러 프로세스가 동시에 데이터를 쉽게 다룰 수 있습니다.
3. 공유 메모리 : 데이터 자체를 공유하도록 지원합니다. 프로세스간 메모리 영역을 공유할 수 있도록 해줍니다. 중개자 없이 바로 접근이 가능해서 빠릅니다.
4. 소켓 : 네트워크 소켓 통신을 통해 공유합니다.

### Race condition

1. 커널 모드에서 실행하는 도중 인터럽트 발생 : 커널모드에서는 cpu 제어권을 뺏지 못하도록 합니다.
2. syscall을 해서 커널 모드로 진입했는데 문맥 교환이 발생할 때 : 커널 모드에서 작업할 경우 타이머가 되어도 cpu 제어권을 넘기지 않도록 함
3. 멀티 프로세서 환경에서 공유 메모리에 접근했을 떄 : 공유 데이터에 lock을 겁니다

### 인터럽트

프로그램을 실행하는 도중 예기치 못한 상황이 발생할 경우 현재 실행중인 작업을 중단하고 발생 상황을 먼저 처리하고 복귀하는 것을 말합니다.


### 캐시의 지역성

* 캐시를 참조할 때 캐시에 해당 데이터가 있을 확률인 적중률을 극대화 시키기 위해 지역성의 원리를 사용합니다.

1. 시간 지역성 : 최근 참조된 것은 다시 참조된다.
2. 공간 지역성 : 참조된 곳과 인접한 주소의 애들이 참조된다.

* caching line : 캐시에 데이터를 저장할 떄 특정 자료구조를 사용해서 묶음으로 저장하게 되는 것(태그들의 묶음)

## DB

### Key 

키는 검색, 정렬시 튜플을 구분할 수 있는 기준이 되는 attribute입니다.

1. 후보키
  튜플을 유일하게 식별하기 위해 사용하는 속성의 부분집합
  1. 유일성 : 키 하나로 튜플을 유일하게 식별할 수 있음
  2. 최소성 : 꼭 필요한 속성으로만 구성
2. 기본키
  후보키 중 선택한 메인 키
  1. Null값을 가질 수 없음
  2. 중복된 값을 가질 수 없습니다.
3. 대체키
  후보키 중 기본키를 제외한 나머지 키
4. 슈퍼키
  유일성은 만족하지만, 최소성은 만족하지 못하는 키입니다.

### JOIN

조인 : 두 개 이상의 테이블이나 데이터베이스를 연결해서 검색하는 방법입니다. 적어도 하나의 칼럼을 공유하고 있어야 합니다.

1. INNER JOIN
  교집합, 중복된 값을 보여줍니다.
2. LEFT OUTER JOIN
  왼쪽 테이블 기준으로 join해서 기준 테이블과 조인테이블의 중복된 값을 보여줍니다.
3. RIGHT OUTER JOIN
  오른쪽 테이블 기준으로 join
4. FULL OUTER JOIN
  양쪽 테이블의 모든 데이터가 검색됩니다.
5. CROSS JOIN
  모든 경우의 수를 전부 표현해줍니다.
6. SELFT JOIN
  자기자신과 join하는 것입니다.
  
### SQL Injection

해커에 의해 조작된 SQL 쿼리문이 데이터베이스에 그대로 전달되어 비정상적 명령을 실행시키는 것입니다.

* 공격
  1. 인증 우회
  2. 데이터 노출
  
* 방어
  1. input 값 받을 때 특수문자 여부 검사
  2. sql 서버 오류 발생시 에러 메세지 감추기(일반 사용자는 view로만 접근해서 에러 볼 수 없도록함)

### SQL / NOSQL

* SQL (관계형 DB)
  sql를 사용하면 rdbms에서 데이터를 저장, 수정, 삭제, 검색할 수 있다.
  
  1. 정해진 데이터 스키마에 따라 테이블에 저장된다.
  2. 관계를 통해 여러 테이블에 분산된다.
  
  스키마를 준수하지 않은 레코드는 테이블에 추가할 수 없으며, 데이터의 중복을 피하기 위해 관계를 이용합니다.
  
* NoSQL (비관계형 DB)

  NoSQL에서는 레코드를 문서라고 부른다.
  
  NoSQL에서는 다른 구조의 데이터를 같은 컬렉션에 추가가 가능합니다. 관계형 데이터베이스처럼 여러 테이블에 나눠담지 않고, 관련 데이터를 동일한 컬렉션에 넣습니다.
  
  데이터가 중복되어 서로 영향을 줄 위험이 있습니다. 조인을 잘 사용하지 않고 자주 변경되는 데이터일 때 효율적입니다.
  
* 확장

  1. 수직적 확장 : 데베 서버의 성능을 향상 시키는 것
  2. 수평적 확장 : 더 많은 서버를 추가하고 데베가 전체적으로 분산되어 하나의 데이터베이스가 여러 호스트에서 작동됨을 말합니다.
  
  sql 데베는 일반적으로 수직적 확장, 수평적 확자은 Nosql에서만 가능합니다.


* SQL 장점
  * 스키마가 명확하게 정의되어 있어 데이터 무결성을 보장합니다.
  * 데이터는 중복 없이 한 번만 저장됩니다.
* 단점
  * 스키마를 사전에 계획해야 함
  * 수직적 확장만 가능
* 관계를 맺고 있는 데이터가 자주 변경될 때, 스키마가 명확할 때 좋습니다.
  
* nosql 장점
  * 스키마가 없어서 유연함
  * 데이터 읽는 속도 빠릅니다
  * 수평, 수직 확장이 가능합니다
* 단점
  * 데이터 중복을 계속 업데이트 해야 합니다
  * 데이터가 여러 컬렉션에 중복되어 있기 대문에 모든 컬렉션에서 수정해야 합니다.
* 정확학 데이터 구조를 알 수 없을 때, 데이터 변경은 별로 없지만 많이 읽어와야 할 때 좋습니다.
  
### anomaly

잘못된 테이블 설계로 인해 발생하는 이상현상

1. 삽입 이상
  기본키가 예를 들어 학생 명, 수강 과목인데 수강 정보가 없으면 null로 넣지 못하고 미수강이라는 불필요한 데이터를 추가해야 삽입할 수 있는 현상
2. 갱신 이상
  특정 과목의 이름이 a에서 b로 변경되었ㅇ르 때 그 과목을 수강한 모든 사람들의 과목 이름을 바꿔야 하는데 일부를 바꾸지 못하면 데이터가 불일치되는 형상
3. 삭제 이상
  튜플 삭제로 인해 꼭 필요한 데이터까지 함께 삭제되는 문제
  
  
### 정규형

정규형 : 특정 조건을 만족하는 릴레이션의 스키마의 형태

1. 제 1 정규형
  속성의 도메인이 오직 원자값을 가져야 합니다.
2. 제 2 정규형
  비주요 속성이 주요 속성에 대해 완전 함수적 종속일때. x->y 일때 x의 값을 알면 y를 식별할 수 있고, x의 값에 따라 y가 달라질때
3. 제 3 정규형
  비주요 속성이 기본키에 대해 이행적으로 종속되지 않을 때. x->y, y->z 일 때 x->z
4. BCNF
  모든 결정자가 key인 경우
  
* 해결하는 것
  1. 아노말리
  2. 새로운 데이터 형을 추가할 때 구조의 변경을 최소화 할 수 있습니다.
* 단점
  1. 릴레이션의 분해로 join연산이 많아집니다.
  
### 인덱스

RDBMS에서 검색 속도를 높이기 위한 기술

테이블의 칼럼을 색인화합니다. 테이블 생성시 3가지 파일이 생성됩니다. FRM, MYD, MYI

* 인덱스 관리
  1. B+ Tree. 인덱스 칼럼의 값을 변환하지 않고 원래의 값을 이용해 인덱싱
  2. Hash. 매우 빠른 검색 지원. 부등호 연산의 경우 문제가 발생할 수 있기 때문에 동등 연산에만 특화
  
* 단점
  * 인덱스 생성시, 파일 크기가 증가합니다.
  * 한 페이지를 동시에 수정할 수 있는 병행성이 줄어듭니다.
  * 레코드를 추가/삭제할 때 성능이 떨어집니다.
  * 데이터 변경 작업이 자주 일어나면 인덱스를 재작성해야합니다.
  
* 사용하기 좋을 때
  1. Where 절에서 자주 사용되는 column
  2. 외래키가 사용되는 column
  3. join에 자주 사용되는 column
* 피해야 할 때
  1. 데이터 중복도가 높은 column
  
### 트랜잭션

트랜잭션이란 데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위

* 상태 변화 : sql 질의어를 통해 DB에 접근
  - select
  - insert
  - update
  - delete
  
* 작업 단위 : 많은 sql 명령문들을 사람이 정하는 기준에 따라 정하는 것

* 특징
  1. 원자성 : 트랜잭션이 db에 모두 반영되거나 전혀 아니거나
  2. 일관성 : 작업 처리 결과는 항상 일관성 있어야 함
  3. 독립성 : 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때 서로 다른 트랜잭션에 연산에 끼어들 수 없음
  4. 지속성 : 트랜잭션이 성공적으로 완료되면, 결과는 영구적으로 반영된다.
  
* commit : 하나의 트랜잭션이 끝났고, db가 일관성 있는 상태일때 이를 알려주기 위해 사용하는 연산입니다

* rollback : 트랜잭션이 비정상적으로 종료되어 트랜잭션 원자성이 깨진 경우입니다.

* 트랜잭션 관리
  1. UNDO : 정상적으로 종료되지 않은 트랜잭션이 변경한 페이지들을 원상복구 하는 것
  2. REDO : 이미 커밋한 트랜잭션의 수정을 재반영 합니다.
  
### 트랜잭션 격리 수준

격리 수준 : 트랜잭션에서 일관성 없는 데이터를 허용하도록 하는 수준

locking을 통해 한 트랜잭션이 db를 다루는 동안 다른 트랜잭션이 관여하지 못하도록 해야 합니다. locking의 범위에 따라 성능이 달라집니다.

1. Read Uncommitted - level 0 
  처리중인 데이터를 다른 트랜잭션이 읽는 것을 허용합니다. 데이터 일관성 유지가 불가능합니다.
2. Read committed - level 1
  select 문장이 수행되는 동안 해당 데이터에 lock이 걸립니다.
  트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없습니다. sql 서버의 default
3. Repeatable Read - level 2
  트랜잭션이 완료될때까지 select 문장이 사용하는 모든 데이터에 lock이 걸립니다.
4. Serializable - level 3
  select 문장이 사용하는 모든 데이터에 lock이 걸립니다. 완벽한 읽기 일관성 모드를 제공합니다.
  
* 낮은 단계 격리 수준을 사용하면 다음 문제가 발생합니다.
  1. Dirty Read : 커밋되지 않은 수정중인 데이터를 다른 트랜잭션이 읽을 수 있습니다.
  2. non-repeatable read : 한 트랜잭션에서 데이터를 두 번 읽는데 한 번 읽고 나서 수정작업이 이루어져서 다음번에 읽을 때 결과가 다르게 나오는 것입니다.
  3. Phantom read : 두번 읽는데, 두번째에서 첫번째에는 없는 애가 나타나는 것
  
## SW Engineering

### 클린 코드, 리팩토링

1. 네이밍
2. 오류 없어야
3. 중복 없어야
4. 의존성 줄이기
5. 클래스/메소드가 한 가지 일만 처리하게

리팩토링 : 코드의 외부 기능은 바꾸지 않으면서 내부 구조를 바꾸는 것. 소프트웨어에 새로운 기능을 추가해야 할 때 

### TDD

테스트 주도 개발입니다. 

테스트 케이스를 먼저 작성하고 실제 코드를 개발합니다.

### 애자일

협력과 피드백을 더 자주, 일찍, 잘 하는 것을 의미합니다.

개발 과정에 있어서 시스템 변경사항을 유연하게 대응할 수 있는 방법론을 제시합니다.

### OOP

코드의 재사용성을 높이고 중복을 없애는 프로그래밍 방법입니다. 객체의 유기적인 관계를 통해 프로세스가 진행됩니다.

* 설계원칙(SOLID)
  1. Single responsibility - 하나의 클래스는 하나의 역할만 해야 함.
  2. Open closed : 확장에는 열려있고, 변경에는 닫혀있어야 한다.
  3. LSP : 자식이 부모의 자리에 항상 교체될 수 있어야 함.
  4. interface segregation : 인터페이스가 잘 분리되어서, 클래스가 꼭 필요한 인터페이스만 구현하도록 해야한다.
  5. Dependency inversion : 상위 모듈이 하위 모듈에 의존하면 안된다.
  
  
### devops

development + operation : 소프트웨어 개발자와 정보기술 전문가 간의 소통을 강조하는 환경과 문화를 의밓바니다.

