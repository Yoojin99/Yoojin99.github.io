---
title:  "C다데알 - 5장 큐"
excerpt: "다양한 예제로 학습하는 데이터 구조와 알고리즘 - 5장 큐"

categories:
  - C다데알
  
tags:
  - C
  - 공부
  - 큐
last_modified_at: 2020-07-05
---

## 5.1 큐란?

큐는 연결 리스트와 스택과 유사하게 데이터를 저장하는 데이터 구조이다. 큐에서도 데이터가 도착하는 순서가 중요하다. 일반적으로 큐는 사람들이나 물건들이 한 줄로 서서 차례를 기다리는 것과 비슷하다.

정의 : 큐는 데이터의 삽입이 한쪽 끝(뒤, rear)에서 이루어지고 삭제는 다른 쪽 끝(앞, front)에서 이루어지는 정렬된 리스트이다. 가장 처음 삽입된 항목이 맨 먼저 삭제된다. 그러므로 선입선출(FIFO), 후입선출(LILO)리스트라고 불리낟.

스택에서처럼 큐는 두 가지 동작이 있다. 항목이 큐에 삽입될 때 인큐(EnQueue), 항목이 큐로부터 제거될 때 디큐(DeQueue)라고 한다. 빈 큐로부터 디큐하려고 하는 것을 언더플로우(underflow),
꽉 찬 큐에 항목을 인큐하려고 하는 것을 오버플로우(overflow)라고 한다. 이 두 경우는 일반적으로 예외로 처리된다. 

## 5.2 어떻게 큐가 사용되는가? 

큐는 예약 접수대의 줄로 생각하면 편하다. 큐는 데이터의 순서를 유지해야 할 필요가 있는 경우에 매우 유용하다.

## 5.3 큐 ADT

**큐의 주된 연산들**

1. EnQueue(int data) : 큐의 가장 끝에 항목을 삽입한다.
2. int DeQueue() : 큐의 가장 앞에 있는 항목을 제거하고 리턴한다.

**큐의 보조 연산들**

1. int Front() : 큐의 가장 앞에 있는 항목을 제거하지 않고 리턴한다.
2. int QueueSize() : 저장된 항목의 개수를 리턴한다.
3. int IsEmptyQueue() : 저장된 항목이 없는지를 나타낸다.

## 5.4 예외들

다른 ADT들과 유사하게 빈 큐에 대해 디큐하려고 시도할 때, 꽉 찬 큐에 인튜하려고 할 때 예외가 발생한다.

## 5.5 큐의 적용 사례들

**직접적인 적용 사례들**

1. (우선순위가 같은) 시스템 예약 작업 도착 순서대로 처리하기
2. 매표소의 줄이나 또는 먼저 온 순서대로 서비스를 받는 실제 세계 상황을 시뮬레이션
3. 멀티프로그래밍
4. 비동기적 데이터 전송(파일 입출력, 파이프, 소켓)
5. 고객 센터에서 고객의 대기 시간
6. 수퍼마켐에서 계산대 점원 수 결정하기

**간접적인 적용 사례들**

1. 알고리즘을 위한 보조적 데이터 구조
2. 다른 데이터 구조의 구성 요소

## 5.6 큐의 구현

다음은 흔하게 사용되는 방법들이다.

1. 간단한 원형 배열에 기초한 구현
2. 동적 원형 배열에 기초한 구현
3. 연결 리스트 구현

**왜 원형 배열인가?**

먼저, 스택에서 사용했던 것처럼 단순한 배열을 사용할 수 있는지 살펴보자. 큐는 삽입은 한쪽 끝에서, 삭제는 다른 쪽 끝에서 이루어진다. 그런데 몇 번의 삽입과 삭제 연산 뒤에 다음 그림과 같은 상황에 처하는 경우가 생긴다.

즉 배열의 앞쪽 공간이 낭비되는 현상이 생기므로 기본 배열로 큐를 구현하는 것은 좋지 않다.

원형 배열은 마지막 항목과 첫 번째 항목이 연결되는 형태이다. 이를 이용하여 앞쪽에 빈 공간이 있으면 뒤(rear) 포인터가 다음 빈 공간으로 쉽게 이동할 수 있다.

*간단한 원형 배열이나 동적 원형 배열 구현은 스택 배열 구현과 유사하다.*

**간단한 원형 배열 구현**

*가장 처음에 앞과 뒤 포인터 모두 -1을 가리키게 하여 큐가 비었다는 것을 알린다.*

```C
struct ArrayQueue{
  int front, rear;
  int capacity;
  int *array;
}

struct ArrayQueue *Queue(int size){
  struct ArrayQueue *Q = malloc(sizeof(struct ArrayQueue));
  if(!Q)
    return NULL;
    
  Q->capacity = size;
  Q->front = Q->rear = -1;
  Q->array = malloc(Q->capacity * sizeof(int));
  
  if(!Q->array)
    return NULL;
  
  return Q;
}

int IsEmptyQueue(struct ArrayQueue *Q){
  //조건이 참이면 1이 리턴되고 아니면 0이 리턴된다.
  return(Q->rear == -1);
}

int IsFullQueue(struct ArrayQueue *Q){
  return((Q->rear)+1 % Q->capacity == Q->front);
}

int QueueSize(){
  return (Q->capacity - Q->front + Q->rear+1) % Q->capacity;
}
```

