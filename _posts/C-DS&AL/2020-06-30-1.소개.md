---
title:  "C다데알 - 1장 소개"
excerpt: "다양한 예제로 학습하는 데이터 구조와 알고리즘 - 1장 소개"

categories:
  - C다데알
  
tags:
  - C
  - 공부
last_modified_at: 2020-07-05
---

다양한 예제로 학습하는 데이터구조와 알고리즘 (C) 책을 도서관에서 빌렸다.

보고 부족한 알고리즘 개념들을 공부할 생각이다. 분량이 상당한데 이거를 반납 전까지 모두 볼 수 있을 것 같지 않아서 연장을 2번은 더 해야 할 듯 하다.

정말 많은 내용 중에서 핵심이 되는 내용만 추렸다. 책에 설명이 자세히 나와 있고, 문제 등 풀 수 있는 예제들이 많아서 책을 직접 사는 것도 좋을 것 같다는 생각이 든다.

1장 소개
=========

## 1.1 변수

x, y, z. x = y+1 같은 수식에는 이름(x, y)가 있고 이 이름에는 값(데이터)가 있다.

변수는 CS에서 데이터를 저장하는 역할을 한다.

## 1.2 데이터형

변수들이 가질 수 있는 값의 종류를 의미한다. 즉, 미리 정해진 특성을 가진 값들의 집합이다.

예를 들어 정수, 부동 소수점 숫자, 문자, 문자열 등이 있다.

데이터형은 크게 두가지 종류가 있다.
* 시스템 정의 데이터형(원시 데이터형)
* 사용자 정의 데이터형

### 1) 시스템 정의 데이터형(원시 데이터형)
ex) int, float, char, double, bool

각각의 원시 데이터형에 할당된 비트 수는 프로그래밍 언어, 컴파일러, 운영체제마다 다르다.

최대로 표현할 수 있는 값의 범위를 도메인이라고 하는데, 데이터형의 크기에 따라 도메인도 달라진다.

> int는 2바이트 / 4바이트 를 사용할 수 있다.
> > 2바이트(16bit)일 경우 => -2^15 ~ 2^15 -1
> > 4바이트(32bit)일 경우 => -2^31 ~ 2^31 -1

### 2) 사용자 정의 데이터형
C / C++의 구조체와 Java의 클래스가 좋은 예이다.
~~~
struct newType{
  int data1;
  float data2;
};
~~~

## 1.3 데이터 구조
데이터 구조는 효율적으로 데이터를 사용하기 위해 컴퓨터에 데이터를 저장하고 정리하는 특별한 방법이다.

즉 데이터를 정리하고 저장하는데 특화된 체제이다.

배열, 파일, 연결 리스트, 스택, 큐, 트리, 그래프가 있다.

항목을 정리하는 방법에 따라 두 종류로 나뉜다.

### 1) 선형 데이터 구조
항목들이 순차적 차례에 따라 접근되지만 순차적으로 저장되어야 하는 것은 아니다.(연결 리스트, 스택, 큐)

### 2) 비선형 데이터 구조
항목들이 비선형의 차례로 저장 / 접근된다.(트리, 그래프)

## 1.4 추상 데이터형
ADT(Abstract Data Type)라고 한다. ex) 연결 리스트, 스택, 큐, 우선순위 큐, 이진 트리, 딕셔너리, 서로 소 집합, 해시 테이블, 그래프 등등

원시 데이터는 기본 연산을 지원한다. 사용자 정의 데이터형에서는 코더가 직접 연산을 정의해야 한다.

문제를 푸는 과정을 단순화시키기 위해 데이터 구조와 연산을 합쳐 놓은 것을 추상 데이터형이라고 한다.

ADT는 두 부분으로 구성된다.

1. 데이터의 선언 ex) 스택
2. 연산의 선언 ex) 스택에는 스택 만들기, push, pop 등등

ADT는 각각의 사용 용도가 있으며 몇 ADT는 특정 용도에 최적화되어 있다.

## 1.5 알고리즘이란?
주어진 문제를 풀기 위해 단계별로 과정을 제시한 것, 즉 **주어진 문제를 풀기 위한 단계별 지시사항들이다.**

## 1.6 알고리즘 분석 이유
한 문제를 푸는 데는 여러가지의 알고리즘이 존재할 수 있다. 분석을 통해 시간, 공간적으로 효율적인 알고리즘을 선택할 수 있다.

## 1.7 수행 시간 분석
문제의 입력의 크기가 증가함에 따라 처리 시간이 얼마나 증가하는지 분석하는 것이다.

## 1.8 알고리즘 비교?
1. 실행 시간 : 컴퓨터마다 달라지기 때문에 좋은 기준이 아님.
2. 실행된 구문의 수 : 언어, 코더에 따라 달라지므로 좋은 기준이 아님.
3. 알고리즘의 수행 시간을 입력 크기 n에 따른 함수 f(n)으로 표현하고 함수들을 비교. 기계와 사람에 무관함.

## 1.9 증가율이란?
입력하는 함수에 따라 수행 시간이 증가하는 비율을 의미한다.

예를 들어 복잡도 함수가 n^4 + 2n^2 + 100이면 n^4 항에 가장 많은 영향을 받을 것이다.

이때 n^4가 가장 큰 증가율을 가지고 있다고 한다.

## 1.10 많이 쓰이는 증가율

|시간 복잡도|명칭|
|------|---|
|1|상수형|
|logn|로그형|
|n|선형|
|nlogn|선형로그형|
|n^2|2차형|
|n^3|3차형|
|2^n|지수형|

보통 2^(2^n)>n!>지수형>n차형>nlogn>log(n!)>n>2^(logn)>log^2n>sqrt(logn)>loglogn>1 순이다.

## 1.11 분석의 종류

세 가지 종류의 분석이 있다.

1. 최악의 경우 
2. 최선의 경우
3. 평균의 경우 : 입력이 무작위라 가정. 하한 시간<평균시간<상한시간

## 1.12 점근적 표기법
최선, 평균, 최악의 경우 모두에 대해 상한과 하한을 찾아야 한다.

## 1.13 빅-오 표기법
상한을 찾기 위한 표기법이다.

f(n) = O(g(n))으로 쓴다. n이 클 때, f(n)의 상한이 g(n)이라는 뜻이다.

즉 n의 값이 클 때 f(n)에 대해 최대의 증가율이 g(n)이라는 것이다.

정의는 다음과 같다.

~~~
O(g(n)) = {f(n) : n>= n0인 모든 n에 대해 0<=f(n)<=c*g(n)을 만족하는 양의 상수 c와 n0가 존재한다}
~~~

g(n)은 f(n)의 점근적 상한이다. 정의에서 n이 클 때를 주목해서 보는 이유는 n이 작을 때의 증가율은 중요하지 않기 때문이다.

O(g(n))은 g(n)의 증가율보다 작거나 같은 함수들의 집합이다.

**유일성이 없다.**

이게 무슨 말이냐 하면 점근적 상한을 증명하는 유일한 n0와 c의 값은 없다는 말이다. 즉, 한 함수에 대해 다양한 n0와 c가 존재가능하다는 소리다.

## 1.14 오메가 표기법
하한을 찾게 해준다.

~~~
오메가(g(n)) = {f(n): n>=n0인 모든 n에 대해 0<=c*g(n)<=f(n)을 만족하는 양의 상수 c와 n0가 존재한다.}
~~~

여기서 빅오 표기법과는 반대로, g(n)은 f(n)의 엄밀한 점근적 하한이을 의미한다.

## 1.15 세타 표기법
주어진 함수의 상한과 하한이 같은지 아닌지를 결정한다. 알고리즘의 평균 수행 시간은 항상 하한과 상한 사이에 존재한다.

~~~
세타(g(n)) = {f(n): n>=n0인 모든 n에 대해 0<=c1*g(n) <= f(n) <= c2*g(n)을 만족하는 양의 상수 c1, c2와 n0가 존재한다.}
~~~

**중요 사항**

최선의 경우 : 하한(오메가)
최악의 경우 : 상한(빅오)
평균 : 평균 수행시간(세타)

## 1.16 점근적 분석이라 부르는 이유?
g(n)은 n의 값이 클 경우에 f(n)에 근접한 또 하나의 고건이다. 이런 곡선을 수학에서는 점근적 곡선이라 부른다.
이래서 알고리즘 분석을 점근적 분석이라 하는 것이다.

## 1.17 점근적 분석 규칙
#### 1. 반복문 : 반복문 수행 시간은 **루프 안의 문장들의 수행 시간(조건문 수행 시간 포함) X 반복 횟수**

~~~
for(int i=0; i<n; i++) //n번 수행
  m += 2; //일정한 시간 c
  
전체 시간 = c * n = cn = O(n)
~~~

#### 2. 중첩 반복문 : 안쪽에서 바깥쪽으로 분석한다. 전체 수행 시간은 **각각의 반복문의 수행 시간을 곱한다**.

~~~
for(int i=0; i<n; i++) //n번 수행
  for(int l=0; l<n; l++) //n번 수행
    m += 2; //일정한 시간 c
  
전체 시간 = c * n * n = cn^2 = O(n^2)
~~~

#### 3. 연속된 문장들 : **각 문장의 수행시간(복잡도)를 더한다**.

~~~
x += 1; //일정한 시간

for(int i=0; i<n; i++) //n번 반복
 m += 2; //일정한 시간
 
전체 시간 = c0 + n*c1 = O(n)
~~~

#### 4. If-else : 최악의 경우는 **If / else에 속하는 부분 중 더 오래 걸리는 쪽 시간을 더한 경우**이다.

~~~
if(i==1)
  return false; // 상수
else
  for(int i=0; i<n; i++) //n번 반복
     m += 2; //일정한 시간
~~~

#### 5. 로그형 : 어떤 알고리즘의 **문제의 크기를 일부(일반적으로 1/2) 줄이는데 일정한 시간이 걸리면 O(logn)**

~~~
for(i=1; i<=n;)
  i *= 2;
~~~

매 반복이 이루어질때마다 i는 두배가 된다. k번 반복되었다면, 2^k = (n+c)이 되어 반복문을 빠져나올 것이다.

양변에 로그를 취하면

k * log2 = logn(대략적)
k = logn

따라서 전체 걸린 시간은 O(logn)이다. 이진 탐색도 여기에 해당된다.

## 1.18 표기법의 특성

* 이행성(Transitivity) : f(n) = 세타(g(n))이고, g(n) = 세타(h(n))이면 => f(n) = 세타(h(n))이다. 빅오와 오메가에 대해서도 성립한다.
* 반사성(Reflectivity) : f(n) = 세타(f(n))이다. 빅오와 오메가에 대해서도 성립한다.
* 대칭성(Symmetry) : g(n) = 세타(f(n))일때만 (iff, if and only if) f(n) = 세타(g(n))이다.
* 전치 대칭성(Transpose symmetry) : g(n) = 오메가(f(n))일 경우에만 f(n) = O(g(n))이다.

어려운 용어로 나타내고 있지만 다시 생각해보면 쉬운 개념들이다.

## 1.19 자주 사용되는 로그함수와 급수

* 로그함수(생략. 고등학교 수학 개념)
* 등차급수 n(n+1)/2
* 등비급수 x^(n+1)-1/(x-1) (x!=1)
* 조화급수 logn == (1+1/2+1/3+ ... + 1/n)
* log1 + log2 + ... + logn = nlogn
* 1^p + 2^p + ... + n^p = {n^(p+1)}/(p+1)

## 1.20 분할 정복을 위한 마스터 정리

마스터 정리는 일반적으로 재귀적으로 호출되는 함수에 대해 시간 복잡도를 알고 싶을 때 사용한다. 
시간 복잡도를 계산하기 위한 방법 중 하나로, 간단한 방법이다.

마스터 정리를 사용하기 위해선 시간 복잡도 점화식이 아래와 같이 정의가 되어야 한다.
~~~
T(n) = aT(n/b) + f(n)
~~~

이를 쓰기 위해선 세가지 제약 조건이 있다.

1. f(n)은 다항식이어야 한다. 다항식이 아니더라도 극명하게 적용될 수 있음을 증명하면 사용될 수 있다.
2. a와 b가 a>=1, b>1 인 양의 실수이어야 한다. 재귀를 호출할때는 그 호출비용이 현재보다 작아야 한다. 따라서 b가 1보다 큰 값을 가져야 한다.
3. 정규조건은 af(n/b) <= cf(n)을 만족하면서 c<1을 만족하는 c가 존재해야 한다. 이 조건은 부분 문제가 현재 문제보다 작아져야 한다는 것을 의미한다.

재귀 관계식은 
~~~
T(n) = aT(n/b) + 세타(n^k * log^p(n))
~~~
의 형태로 나타낼 수 있다.

이때 a 와 b^k의 관게를 보고 3가지로 나뉠 수 있다.

![마스터정리](https://user-images.githubusercontent.com/41438361/86535315-6e5f0f80-bf1a-11ea-9574-87de393d78f1.JPG) (출처 : https://coloredrabbit.tistory.com/94)

## 1.21 차감 정복 점화식을 위한 마스터 정리
양수 n에 대해 정의된 함수 T(n)이 어떤 상수 c, a>0, b>0, k>=0과 함수 f(n)에 대해 다음과 같은 속성을 갖는다고 하자.

![1](https://user-images.githubusercontent.com/41438361/86535619-8afc4700-bf1c-11ea-9846-e5552e73996f.JPG)

f(n)이 O(n^k)안에 있다면 

![2](https://user-images.githubusercontent.com/41438361/86535621-8f286480-bf1c-11ea-85d4-655eb60496e5.JPG)

## 1.22 상환 분석
상환 분석 => 책에 나온 글이 이해가 잘 안돼서 구글링을 해보니까 비슷했다. 더 공부하고 업데이트 필요.

