---
title:  "C다데알 - 3장 연결"
excerpt: "다양한 예제로 학습하는 데이터 구조와 알고리즘 - 3장 연결 리스트"

categories:
  - C다데알
  
tags:
  - C
  - 공부
last_modified_at: 2020-07-05
---

요즘 다른 프로젝트들 때문에 알고리즘 공부가 소홀했는데 반성해야겠다,,,

## 3.1 연결 리스트란?

연결 리스트(Linked List)는 데이터의 집합을 저장하기 위해 사용되는 데이터 구조이다.

* 연속되는 항목들이 포인터로 연결된다.
* 마지막 항목은 NULL을 포인트한다.
* 프로그램 수행 중 크기가 커지거나 작아질 수 있다. 크기가 유동적!
* (시스템 메모리가 허용하는 한) 필요한 만큼 길어질 수 있다.
* 메모리 공간을 낭비하지 않는다(하지만 포인터를 위한 추가의 메모리를 필요로 한다.)

## 3.2 연결 리스트 ADT

연결 리스트는 추상 데이터형 ADT(Abstract data type)이다. ADT는 컴퓨터 과학에서 자료들과 그 자료들에 대한 연산들을 명기한 것이다.

연결 리스트의 연산은 다음과 같다.

* 주요 연산
1. 삽입 : 항목을 리스트에 추가한다.
2. 삭제 : 지정된 위치의 항목을 리스트로부터 삭제하며 리턴한다.

* 보조 연산
1. 리스트 삭제 : 리스트의 모든 항목을 삭제한다. (리스트도 삭제)
2. 개수 세기 : 리스트의 항목의 개수를 리턴한다.
3. 리스트의 끝으로부터 n번째 항목 찾기 등

## 3.3 연결 리스트를 사용하는 이유?

연결 리스트를 사용하는 이유를 이해하기 위해서는 배열과 연결 리스트의 차이점을 이해하는 것이 중요하다. 둘이 같은 목적으로 사용되기 때문이다.

## 3.4 배열 개요

배열의 항목을 저장하기 위해 메모리 블록 하나가 할당된다. 배열에 있는 요소들은 인덱스로 바로(일정한 시간으로) 접근할 수 있다.

**배열의 항목에 접근하는 데 왜 일정한 시간이 걸리는가?**

배열의 항목에 접근하기 위해서는 항목의 주소가 배열의 기본 주소에 연산이 되어 계산 된다.(기본 주소에 오프셋이 더해짐) 이 과정에서 한 번의 곱셈과 한 번의 덧셈이 사용되는데, 이 두 연산이 일정한 시간이 걸리므로 배열 접근은 일정한 시간으로 수행된다.

**배열의 장점**

1. 간단하고 사용하기 쉽다.
2. 항목에 접근하는 게 더 빠르다.(일정한 시간이 걸리는 접근)

**배열의 단점**

1. 고정된 크기(Static Array) : 배열의 크기는 정적이다(사용하기 전에 배열의 크기를 지정해야 한다.)
2. 한 블록의 할당 : 처음에 배열을 할당할 때 전체 배열을 위한 메모리를 얻지 못할 때도 있다. 
3. 복잡한 위치 기반의 삽입 : 주어진 위치에 항목을 삽입하려면 기존의 항목들을 모두 이동해야 할 수 있다. 부가적인 연산이 더 많이 생길 수 있다.

**동적 배열(Dynamic Array)**

동적 배열(확장 가능 배열, 크기 변경 가능 배열, 동적 테이블, 배열 리스트)은 랜점 접근하는, 크기가 변화는 리스트 데이터 구조로 새로운 항목들이 추가되거나 삭제될 수 있다. 

동적 배열을 구현하는 한 가지 간단한 방법은 처음에 일정한 고정된 크기의 배열로 시작하는 것이다. 이 배열이 가득 차면 원래 배열의 두 배 크기의 새로운 배열을 만든다. 마찬가지로 배열의 항목 수가 절반 이하가 되면 배열의 크기를 반으로 줄인다.

**연결 리스트의 장점**

* 장점

1. 일정한 시간으로 확장 가능하다. 배열을 만들기 위해서는 특정 수의 항목을 위해 메모리를 할당해야 한다. 또 항목을 추가하기 위해서는 새 배열을 만들어 원래 배열에서 새 배열로 항목들을 복사해야 한다. 하지만 이런 배열을 이용한 방법은 시간이 오래 걸린다. 이를 막기 위해 처음에 많은 공간을 할당할 수 있지만 필요한 것보다 공간을 더 많이 할당하여 메모리를 낭비하게 된다. 이때 연결리스트를 사용하면 하나의 항목을 위한 공간으로 시작해서 복사나 재할당 없이 새 항목을 쉽게 추가할 수 있다.

* 단점

1. 개별 항목에 접근하는 시간이 길다. 배열은 랜덤 접근이 가능하므로 O(1)의 시간이 걸리지만 연결리스트는 최악의 경우 O(n)의 시간이 걸린다. 접근 시간에 있어서 배열의 또 다른 장점은 메모리 안에서의 지역성이다. 배열은 연속된 메모리 블록으로 정의되므로 배열의 항목들은 물리적으로 근처에 위치한다. 이것은 현대의 CPU 캐싱 기법에 매우 유리하다.
2. 추가적인 참조 포인터를 위한 메모리 공간이 낭비된다.

## 3.5 연결 리스트와 배열 그리고 동적 배열의 비교

항목|연결 리스트|배열|동적 배열
----|-----------|----|--------
인덱싱|O(n)|O(1)|O(1)
가장 앞에 추가/삭제|O(1)|-|O(n)
가장 끝에 추가/삭제|O(n)|-|배열이 다차지 않았을 경우에는 O(1), 배열이 다 찼을 경우에는 O(n)
중간에 추가/삭제|O(n)|-|O(n)
낭비되는 공간|O(n)|0|O(n)

## 3.6 단일 연결 리스트

일반적으로 "연결 리스트"는 단일 연결 리스트를 의미한다.

정수를 저장한는 연결 리스트는 다음과 같이 선언된다.

```C
struct ListNode {
  int data;
  struct ListNode *next;
};
```

**리스트의 기본 연산**

1. 리스트 탐색하기
2. 리스트에 항목 삽입하기
3. 리스트에서 항목 삭제하기

### 3.6.1 리스트 탐색하기

`head` 노드 포인터가 리스트의 첫 번째 노드를 가리킨다고 가정한다. 리스트를 탐색하기 위해 다음 내용을 수행한다.

1. 포인터를 따라간다.
2. 탐색하면서 노드의 값을 표시한다.(혹은 개수를 계산한다)
3. `next` 포인터가 `NULL`을 가리키면 멈춘다.

`ListLength()` 함수는 연결 리스트를 입력받아 리스트의 노드 개수를 계산한다.

```C
int ListLength(struct ListNode *head){
  struct ListNode *current = head;
  int count = 0;
  
  while(current!=NULL){
    current = current->next;
    count++;
  }
  return count;
}
```

시간 복잡도 : 크기가 n인 리스트를 전체 탐색하는데 O(n)
공간 복잡도 : 하나의 임시 변수 만드는데 O(1)

### 3.6.2 단일 연결 리스트의 삽입

단일 연결 리스트에 삽입하는 경우는 세가지가 있다.

1. 새 노드를 `head` 노드 포인터 앞(가장 처음)에 삽입하기
2. 새 노드를 `tail` 노드 포인터 뒤(리스트 가장 끝)에 삽입하기
3. 새 노드를 리스트의 중간(랜덤한 위치)에 삽입하기

**단일 연결 리스트의 가장 처음에 노드 삽입하기**

새 노드는 현재 `head`노드 앞에 삽입된다. 오직 한 개의 `next` 포인터(새 노드의 `next`)만 수정되고 나면, 두 단계에 걸쳐 수행될 수 있다.

1. 새 노드의 `next` 포인터를 현재의 `head`가 가리키고 있는 노드를 가리키도록 업데이트
2. `head` 포인터가 새 노드를 가리키도록 업데이트

**단일 연결 리스트의 가장 끝에 노드 삽입하기**

이 경우에는 두개의 `next` 포인터를 수정해야 한다.(마지막 노드의 `next`와 새 노드의 `next`)

1. 새 노드의 `next`는 NULL을 가리킨다.
2. 마지막 노드의 `next`는 새 노드를 가리킨다.

**단일 연결 리스트의 중간에 노드 삽입하기**

새 노드를 삽입하려는 위치가 주어졌다고 가정하자. 이 경우에도 두 개의 `next` 포인터를 수정해야 한다.

1. 6번째 위치에 항목을 추가하려면 5번째 위치에서 멈춰야 한다. 새 노드는 5번째 노드가 가리키는 노드를 가리키게 해야 한다.
2. 5번째 노드는 새 노드를 가리키게 한다.

위의 세 가지 경우를 모두 다루는 코드를 보겠다. 호출되는 함수 뿐 아니라 호출하는 함수에서도 첫 번째 항목의 포인터를 업데이트 해야 하므로, 이중 포인터를 전달해야 한다.
다음은 단일 연결 리스트에 노드를 추가하는 코드이다. 

```C
void InsertInLinkedList(ListNode**head, int data, int position) {
	ListNode* inserted = new ListNode;
	inserted->data = data;

  if(!newNode){ //항상 메모리 에러를 확인해야 한다.
    print("Memory Error");
    return;
  }
  
	if (position == 1 || *head == NULL) {
		inserted->next = *head;
		*head = inserted;
	}
	else {
		ListNode* inserted_prev = *head;
		for (int i = 1; (inserted_prev->next != NULL) && (i < position-1); i++) {
			inserted_prev = inserted_prev->next;
		}

		ListNode* inserted_next = inserted_prev->next;
		inserted_prev->next = inserted;
		inserted->next = inserted_next;
	}
}
```

시간 복잡도 : 최악의 경우에 노드를 리스트의 가장 끝에 추가해야 하므로 O(n)
공간 복잡도 : O(1)




