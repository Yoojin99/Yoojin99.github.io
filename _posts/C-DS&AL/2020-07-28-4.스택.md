---
title:  "C다데알 - 4장 스택"
excerpt: "다양한 예제로 학습하는 데이터 구조와 알고리즘 - 4장 스택"

categories:
  - C다데알
  
tags:
  - C
  - 공부
  - 스택
last_modified_at: 2020-07-05
---

## 4.1 스택이란?

스택은 데이터를 저장하기 위해 사용되는 간단한 데이터 구조이다. 스택에서는 데이터가 도착하는 순서가 중요하다. 쌓여있는 접시들이 좋은 예이다.

* 정의 : 스택은 삽입과 삭제가 한쪽 끝에서 이루어지는, 순서가 매겨진 리스트이다. 이 끝을 Top이라고 부른다. 제일 마지막에 추가된 항목이 가장 먼저 삭제되는 후입선출(LIFO), 선입후출(FILO)리스트라고 부른다.

스택에 항목을 삽입할 때 push, 뺄 때 pop이라 부른다. 빈 스택으로부터 항목을 팝하는 것을 언더플로우(underflow), 가득찬 스택에 항목을 푸시하는 것을 오버플로우(overflow)라고 한다.

## 4.2 스택은 어떻게 사용되는가?

우선순위가 자주 달라지는 작업들을 처리할 경우. ex) 한 개발자가 프로젝트를 위한 작업을 처리하고 있다고 가정한다. 그런데 매니저가 개발자에게 더 중요한 새 업무를 할당했다. 그러면 개발자는 프로젝트를 잠시 접어두고 새 업무를 위한 작업을 시작한다. 이때 또 전화가 울리면 즉시 받아야 하므로 이 작업이 가장 높은 우선순위가 된다. 개발자는 현재의 업무를 대기 목록에 넣고 전화를 받는다. 전화가 끄나면 전화 때문에 미뤄놓았던 업무를 대기 목록에서 꺼내 다시 진행한다.

## 4.3 스택 ADT

**주요 연산들**

1. push(int data) : 데이터를 스택에 넣는다.
2. int Pop() : 스택에 제일 마지막에 추가된 항목을 스택으로부터 삭제하고 리턴한다.

**보조 연산들**

1. int Top() : 스택에 마지막에 추가된 항목을 삭제하지 않고 리턴한다.
2. int Size() : 스택에 저장된 항목의 개수를 리턴한다.
3. int IsEmptyStack() : 스택에 항목이 저장되어 있는지 아닌지를 확인한다.
4. int IsFullStack() : 스택이 가득 찼는지 아닌지를 확인한다.

**예외들**

어떤 연산을 수행하려고 시도할 때 가끔 예외라고 불리는 오류 상황이 발생할 수 있다. 예외는 수행될 수 없는 연산에 의해 '던져진(thrown)'다고 표현된다.
스택 ADT에서는 스택이 비어 있을 경우 팝, 탑 연산이 수행될 수 없다. 빈 스택에 대해 팝/탑 연산을 수행하려고 하면 예외가 발생한다. 가득찬 스택에 항목을 푸시하려고 할 때도 예외가 발생한다.

## 4.4 스택 적용 사례들

**직접적인 적용 사례**

1. 괄호 짝 맞추기
2. Infix를 Postfix로 고치기
3. Postfix 수식 계싼하기
4. 함수 호출 구현하기(재귀 포함해서)
5. 스팬(Span) 찾기
6. 웹 브라우저에서 방문한 페이지 기록 관리하기(뒤로가기 버튼)
7. 텍스트 에디터에서 작업 취소(undo) 과정
8. html과 xml에서 tag 짝 맞추기

**간접적인 적용 사례**

1. 다른 알고리즘을 위한 부가적인 데이터 구조(ex 트리 탐색 알고리즘)
2. 다른 데이터 구조의 구성 요소(큐)

## 4.5 스택의 구현

제일 많이 사용되는 방법은 다음과 같다.

1. 간단한 배열에 기반한 구현
2. 동적 배열에 기반한 구현
3. 연결 리스트 구현

**간단한 배열 구현**

스택 ADT를 구현할 떄는 하나의 배열이 사용된다. 배열에 항목을 왼쪽에서 오른쪽으로 추가하면서 변수 하나를 사용하여 탑 항목의 인덱스를 추적한다.

```C
#include<stdio.h>
#define MAX_STACK_SIZE 100
 
int stack[MAX_STACK_SIZE];
int top=-1;
 
int IsEmpty(){
    if(top<0)
        return true;
    else
        return false;
    }
int IsFull(){
    if(top>=MAX_STACK_SIZE-1)
        return true;
    else
        return false;
}
 
void push(int value){
    if(IsFull()==true)
        printf("스택이 가득 찼습니다.");
    else
        stack[++top]=value; 
}
 
int pop(){
    if(IsEmpty()==true)
        printf("스택이 비었습니다.");
    else 
        return stack[top--];
}
 
int main(){
    
    push(3);
    push(5);
    push(12);
    printf("%d ",pop());
    printf("%d ",pop());
    printf("%d ",pop());
 
    return 0;
}
```

**코드 수정 필요**

**성능과 한계**

1. 성능 
스택 안의 항목의 개수를 n이라고 하면 스택 연산 복잡도는 다음과 같다.

|||
|-|-|
|공간 복잡도(n번의 푸시 연산)|O(n)|
|Push()의 시간 복잡도|O(1)|
|Pop()의 시간 복잡도|O(1)|
|Size()의 시간 복잡도|O(1)|
|IsEmptyStack()의 시간 복잡도|O(1)|
|IsFullStack()의 시간 복잡도|O(1)|
|DeleteStack()의 시간 복잡도|O(1)|

2. 한계
스택 크기의 최대 값이 미리 정해져야 하고 바뀔 수 없다.

**동적 배열 구현**

기존에는 top이라는 인덱스 변수를 써서 스택에 가장 최근에 추가된 항목의 인덱스를 가치키게 했다. 해결해야 하는 문제는 고정된 크기의 배열 스택의 모든 항목이 다 찼을 때 어떻게 처리하느냐이다.

1. 첫번째 시도

스택이 가득 찰 때마다 배열의 크기를 1씩 증가시킨다면?

* push() : S[]의 크기를 1증가
* pop() : S[]의 크기를 1감소

이 접근 방법의 문제점 : 이 방식으로 배열 크기를 증가시키는 것은 비용이 너무 크다. O(n^2)

2. 반복적인 두 배 확장

배열 두 배 확장 기법을 사용하여 복잡도를 개선해본다. 배열이 가득 차면, 크기가 2배인 새 배열을 만들어 항목들을 복사한다. 
